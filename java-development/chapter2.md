## Java开发规范（二）| 基础编码规范—从“能跑”到“好维护”的第一步

## 前言

如果说开发规范是大厂研发体系的基石，那**基础编码规范**就是基石中的基石——它是项目启动阶段第一个需要团队统一的“共识”，直接决定了后续代码的可读性、可维护性和协作效率。

很多团队初期“快速上线”忽略基础规范，后期会面临致命问题：新人接手3天看不懂代码、重构时改一处牵一发而动全身、线上bug因“变量名模糊”“吞异常”排查半天。

基础编码规范的核心目标，是让团队用“同一套语言写代码”，解决“写得快”和“看得懂、改得顺”的矛盾。本文从“命名、注释、语法避坑、参数校验”四个核心维度，拆解大厂必守的基础规范，每个规则都配 **正反示例+工具校验+落地技巧**，看完就能直接在团队推行。

## 一、命名规范【强制】：见名知意，拒绝“猜谜游戏”

命名是代码的“脸面”，大厂命名的核心原则是：**不依赖注释，仅看名称就能理解“业务含义+数据类型”**，坚决杜绝“缩写不明确、拼音混合、单字母变量”。

### 1\. 类/接口/枚举：大驼峰命名，明确“业务域+角色”

### 2\. 方法名：小驼峰命名，动词开头+明确语义

- **核心规则**：
- **大厂常用动词前缀（必记）**： 动词前缀 适用场景 示例 get 简单查询（单条数据） `getUserById(Long userId)` query 复杂查询（多条件/分页） `queryOrderByUserIdAndDate` find 查找（可能返回null/集合） `findValidOrders(Long userId)` create 新建（无ID，创建后返回） `createUser(UserDTO userDTO)` save 保存（有ID更新，无ID新增） `saveOrder(OrderDTO orderDTO)` update 更新（指定字段） `updateOrderStatus` delete 删除（物理删除/逻辑删除） `deleteUserById` validate 参数校验（返回布尔/抛异常） `validateLoginParam` calculate 计算（如金额、积分） `calculateOrderAmount` - **正确示例**：`getUserById(Long userId)`、`updateOrderStatus(Long orderId, Integer status)`、`validateLoginParam(LoginRequest request)`
- **错误示例**：`get1(Long id)`（无意义数字）、`doOrder()`（语义模糊）、`userInfo(Long id)`（无动词）
- **避坑点**：避免冗余命名，如 `getUserByUserId`（直接 `getUserById`，`userId`的 `User`与方法所属 `UserService`重复）。

### 3\. 变量名：小驼峰命名，禁止单字母（循环变量除外）

### 4\. 常量/静态变量：全大写+下划线分隔，类顶部集中定义

### 5\. 包名：全小写+业务域分层，禁止大写/下划线

## 二、注释规范【强制】：精准有用，拒绝“废话文学”

注释的核心作用是“补充代码无法表达的信息”，而非重复逻辑。大厂注释的原则是：**“代码是骨架，注释是灵魂”，但灵魂不能冗余**。

### 1\. 类/接口注释：Javadoc格式，必含“核心信息+依赖”

### 2\. 方法注释：复杂方法必写，覆盖“入参+返回值+异常”

### 3\. 代码块注释：复杂逻辑必写，说明“为什么这么做”

### 4\. 禁止注释：冗余、过时、误导性注释

## 三、语法避坑规范【强制】：从根源杜绝低级bug

很多线上故障源于“看似没问题”的语法使用不当——比如集合未指定容量、吞异常、空值未处理。以下是大厂高频踩坑点，每个都有“禁止行为+正确做法+工具校验”。

### 1\. 集合使用：指定容量+线程安全+类型安全

### 2\. 异常处理：禁止吞异常+规范日志+合理抛异常

### 3\. 空值处理：用Optional替代多层判空，避免NPE

### 4\. 并发编程：禁用危险用法，保障线程安全

### 5\. 字符串拼接：循环中用StringBuilder，避免+号

### 6\. 参数校验：前置校验，避免业务逻辑中处理无效参数

## 四、工具支持：让规范“自动化检查”，不用靠自觉

大厂推行基础编码规范，从不是“靠记忆”，而是用工具强制约束——IDE实时提醒、CI/CD流水线阻断违规，大幅降低落地成本。

### 1\. IDE插件（实时检查，写代码时纠正）

#### （1）Alibaba Java Coding Guidelines

#### （2）CheckStyle

### 2\. 静态扫描工具（CI/CD集成，提交时阻断）

#### （1）SonarQube

#### （2）SpotBugs

## 五、团队落地 Checklist（直接复制使用）

检查项

检查内容

责任人

完成标准

命名规范

类/方法/变量/常量/包名是否符合规则

开发人员+代码评审人

无单字母变量、拼音命名，常量全大写

注释规范

类/复杂方法是否有Javadoc，代码块注释是否说明意图

开发人员+代码评审人

类注释含功能+作者+日期，方法注释含入参+返回值+异常

语法避坑

集合是否指定容量、异常是否吞掉、空值是否处理

开发人员+工具校验

SonarQube无Critical/Bug级违规

参数校验

方法入参是否校验（null/空字符串/取值范围）

开发人员

用Preconditions/Validator完成前置校验

工具集成

IDE插件是否安装启用，CI/CD是否集成静态扫描

架构师/DevOps

所有开发人员启用Alibaba插件，SonarQube扫描通过才能合并

## 六、常见反模式清单（团队自查用）

1. 类名用小驼峰、方法名用大驼峰；
2. 变量名用单字母（非循环变量）、拼音混合（如 `shangpinList`）；
3. 常量未加 `final`、用小驼峰命名（如 `public static int maxRetry = 3`）；
4. 注释写“废话”（如“循环3次”）、代码修改后注释未同步；
5. 集合初始化不指定容量、遍历删除用 `for-each`；
6. catch异常后空实现、用 `e.printStackTrace()`；
7. 多层 `if (obj != null)`判空、字符串用 `obj == null`判断空；
8. 用 `Executors`创建线程池、成员变量定义为 `public static`（非常量）；
9. 循环中用 `+`拼接字符串；
10. 方法入参未校验（如 `orderId`为null仍查询数据库）；
11. 代码中保留注释掉的无用代码；
12. 使用原始类型集合（如 `List strList = new ArrayList()`）。

## 七、总结：基础规范是“团队协作的第一块砖”

基础编码规范看似简单，但却是团队高效协作的前提——它能让新人入职3天看懂代码，让重构时少踩坑，让线上故障减少80%的低级bug。

大厂的代码之所以“稳定、易维护”，不是因为技术多复杂，而是因为每个程序员都把这些基础规范内化成了“肌肉记忆”。接下来的《接口设计规范》，将基于基础编码规范，进一步定义团队的“协作语言”，让前后端、跨服务协作更顺畅。
