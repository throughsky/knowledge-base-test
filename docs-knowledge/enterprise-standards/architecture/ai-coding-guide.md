# AI Coding 工具辅助方案

本文档定义了如何在架构设计、开发实施、规范落地和管理流程各阶段有效使用AI编码工具来提高效率。

## 一、AI辅助总览

### 1.1 AI辅助矩阵

```
┌────────────────────────────────────────────────────────────────────────────┐
│                           AI 辅助效率矩阵                                   │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│  阶段            │ AI工具用途                   │ 效率提升   │ 风险等级   │
│  ────────────────────────────────────────────────────────────────────────  │
│  需求分析        │ 需求澄清、边界识别            │ 40%       │ 低         │
│  架构设计        │ 方案比较、ADR撰写             │ 60%       │ 中         │
│  接口设计        │ OpenAPI生成、DTO设计          │ 70%       │ 低         │
│  数据库设计      │ Schema生成、索引建议          │ 65%       │ 中         │
│  代码实现        │ 脚手架生成、业务代码          │ 50%       │ 中         │
│  测试编写        │ 单测生成、用例补充            │ 60%       │ 低         │
│  代码评审        │ 预审、问题检测               │ 50%       │ 低         │
│  文档编写        │ API文档、技术文档            │ 75%       │ 低         │
│                                                                            │
│  注: 敏感逻辑(资金、安全)需人工编写，AI仅辅助                               │
└────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 使用原则

```yaml
# AI辅助基本原则
principles:
  1_人工审核必须:
    - AI生成的所有代码必须经过人工Review
    - 敏感逻辑(资金计算、安全校验)需人工编写
    - 生产配置需人工确认

  2_上下文注入:
    - 始终提供项目规范作为上下文
    - 提供相关代码示例作为Few-shot
    - 明确约束条件和输出格式

  3_迭代优化:
    - 分步骤生成，逐步细化
    - 发现问题及时纠正
    - 积累Prompt最佳实践

  4_知识沉淀:
    - 记录有效的Prompt模板
    - 建立项目知识库
    - 定期校验AI输出质量
```

---

## 二、架构设计阶段

### 2.1 需求分析辅助

```markdown
# Prompt模板: 需求分析

## 角色设定
你是一个经验丰富的业务分析师和系统架构师，熟悉Web3金融领域。

## 任务
分析以下需求，识别:
1. 核心功能点
2. 非功能性需求 (NFR)
3. 边界和约束
4. 潜在风险点
5. 需要澄清的问题

## 输入
{粘贴PRD或需求描述}

## 输出格式
### 功能分解
- [ ] 功能点1
- [ ] 功能点2

### 非功能需求
- 性能: {描述}
- 安全: {描述}
- 可用性: {描述}

### 边界约束
- {约束1}
- {约束2}

### 风险识别
| 风险 | 影响 | 缓解措施 |
|------|------|---------|

### 澄清问题
1. {问题1}
2. {问题2}
```

### 2.2 架构方案辅助

```markdown
# Prompt模板: 架构方案比较

## 角色设定
你是Web3金融平台的首席架构师，需要为以下场景设计架构方案。

## 背景
{描述业务场景和技术约束}

## 约束条件
- 技术栈: Java 21 + Spring Boot 3.x
- 部署环境: AWS EKS
- 性能要求: {具体指标}
- 安全要求: {具体要求}

## 任务
提供2-3个可选架构方案，每个方案包含:
1. 架构图 (文本描述)
2. 技术选型理由
3. 优缺点分析
4. 实施成本估算
5. 推荐指数 (1-5)

## 输出格式
### 方案A: {名称}
**架构描述**:
{文字描述架构}

**技术选型**:
| 组件 | 选型 | 理由 |
|------|------|------|

**优点**:
- {优点1}

**缺点**:
- {缺点1}

**成本**: {估算}
**推荐指数**: ⭐⭐⭐⭐

### 推荐结论
推荐方案{X}，理由: {说明}
```

### 2.3 ADR生成辅助

```markdown
# Prompt模板: 生成ADR

## 角色设定
你是架构委员会成员，需要为架构决策撰写ADR文档。

## 决策内容
{描述需要做的技术决策}

## 背景信息
- 当前问题: {描述}
- 驱动因素: {列出}
- 约束条件: {列出}

## 考虑的方案
- 方案A: {简述}
- 方案B: {简述}
- 方案C: {简述}

## 最终决策
选择: {方案X}
理由: {简述}

## 请按以下ADR模板格式输出

```
# ADR-{编号}: {标题}

## 元数据
- 状态: Proposed
- 提议者: {姓名}
- 日期: {日期}

## 背景
{展开描述}

## 决策驱动因素
1. {因素1}
2. {因素2}

## 考虑的方案
### 方案A
...

## 决策
...

## 后果
### 正面
### 负面
### 风险缓解
```
```

---

## 三、代码实现阶段

### 3.1 项目脚手架生成

```markdown
# Prompt模板: 生成服务脚手架

## 角色设定
你是熟悉我们架构规范的Java架构师。

## 项目规范
```
目录结构:
/src/main/java/com/company/{service}/
  /api/controller/     # REST Controllers
  /api/request/        # 入参DTO
  /api/response/       # 出参VO
  /core/domain/        # 领域模型
  /core/service/       # 领域服务
  /infra/persistence/  # 数据库实现
  /infra/cache/        # 缓存实现
  /config/             # 配置类

技术栈:
- Java 21 + Spring Boot 3.2
- MyBatis Plus 3.5
- Redisson 3.25
- 继承 web3fin-parent v1.0
```

## 任务
为 {service-name} 服务生成项目脚手架，包含:

1. pom.xml (继承parent，包含必要依赖)
2. 目录结构 (按规范创建所有目录)
3. Application启动类
4. GlobalExceptionHandler
5. application.yml 模板
6. Dockerfile
7. 基础配置类 (Redis, MyBatis等)

## 服务信息
- 服务名: {service-name}
- 端口: {port}
- 核心功能: {描述}

## 输出
以Markdown代码块格式输出每个文件，标注文件路径。
```

### 3.2 接口代码生成

```markdown
# Prompt模板: 根据OpenAPI生成接口代码

## 角色设定
你是遵循我们编码规范的Java开发工程师。

## 编码规范
```java
// Controller规范
- 使用 @RestController + @RequestMapping
- 入参使用 @Valid 校验
- 返回统一 ApiResponse<T>
- 包含完整日志埋点

// Service规范
- 接口与实现分离
- 使用 @Transactional 管理事务
- 异常使用 BizException

// 错误码规范
格式: WEB3FIN_{MODULE}_{TYPE}_{CODE}
```

## OpenAPI定义
```yaml
{粘贴OpenAPI/Swagger定义}
```

## 任务
生成完整的接口实现代码:
1. Controller (参数校验、日志、响应封装)
2. Service接口
3. ServiceImpl (业务逻辑框架)
4. Request DTO
5. Response VO
6. 相关错误码枚举

## 输出格式
每个类单独一个代码块，包含完整import。
```

### 3.3 数据库Schema生成

```markdown
# Prompt模板: 生成数据库Schema

## 角色设定
你是熟悉我们数据库规范的DBA。

## 数据库规范
```sql
-- 表命名: t_{module}_{name}
-- 字段命名: snake_case
-- 必须包含公共字段:
--   id BIGINT PRIMARY KEY (雪花ID)
--   created_at TIMESTAMP NOT NULL
--   updated_at TIMESTAMP NOT NULL
--   created_by VARCHAR(64)
--   updated_by VARCHAR(64)
--   is_deleted BOOLEAN DEFAULT FALSE
--   version INT DEFAULT 0

-- 索引命名:
--   普通索引: idx_{table}_{columns}
--   唯一索引: uk_{table}_{columns}

-- 金额字段: DECIMAL(36,18)
-- 时间字段: TIMESTAMP (UTC)
```

## 领域模型
{描述实体和关系}

## 任务
生成Flyway迁移脚本:
1. 建表语句 (含公共字段)
2. 索引创建
3. 表和字段注释
4. 初始数据 (如有)

## 输出格式
```sql
-- V1__create_{table}_table.sql
{DDL语句}
```
```

### 3.4 业务代码辅助

```markdown
# Prompt模板: 业务逻辑实现

## 角色设定
你是Web3金融平台的后端开发工程师，熟悉DDD和业务流程。

## 上下文
```java
// 已有的领域模型
{粘贴相关Entity/VO代码}

// 已有的Repository接口
{粘贴Repository接口}

// 相关常量/枚举
{粘贴相关定义}
```

## 业务需求
{详细描述业务逻辑}

## 约束
- 使用本地消息表实现最终一致性
- 金额计算使用BigDecimal
- 包含完整的异常处理
- 包含审计日志记录

## 任务
实现 {方法名} 业务逻辑:
1. 参数校验
2. 业务规则检查
3. 核心逻辑实现
4. 事件发布 (如需要)
5. 返回结果

## 输出
完整的Service实现代码，包含注释说明关键逻辑。
```

---

## 四、测试编写阶段

### 4.1 单元测试生成

```markdown
# Prompt模板: 生成单元测试

## 角色设定
你是注重代码质量的测试工程师。

## 被测代码
```java
{粘贴需要测试的类/方法}
```

## 测试规范
- 使用 JUnit 5 + Mockito
- 测试方法命名: should_{预期行为}_when_{条件}
- 覆盖正常路径、边界条件、异常场景
- 每个测试方法只测一个场景

## 任务
生成完整的单元测试类:
1. 正常场景测试
2. 边界条件测试
3. 异常场景测试
4. Mock依赖配置

## 输出格式
```java
@ExtendWith(MockitoExtension.class)
class {ClassName}Test {
    // 完整测试代码
}
```
```

### 4.2 集成测试生成

```markdown
# Prompt模板: 生成集成测试

## 角色设定
你是熟悉Spring Boot测试的开发工程师。

## 被测接口
```yaml
{粘贴OpenAPI定义或接口描述}
```

## 测试规范
- 使用 @SpringBootTest + TestContainers
- 测试真实的数据库和Redis
- 验证完整的请求-响应流程

## 任务
生成集成测试:
1. 测试容器配置
2. 测试数据准备
3. API调用和断言
4. 数据清理

## 输出
完整的集成测试类代码。
```

---

## 五、代码评审阶段

### 5.1 AI预审检查

```markdown
# Prompt模板: 代码预审

## 角色设定
你是严格遵循编码规范的代码审查员。

## 编码规范
{粘贴或引用架构基本法相关章节}

## 待审代码
```java
{粘贴待审代码}
```

## 审查维度
1. **规范符合性**
   - 目录结构是否正确
   - 命名是否规范
   - 是否使用白名单技术栈

2. **代码质量**
   - 是否有重复代码
   - 圈复杂度是否过高
   - 是否有魔法数字

3. **安全性**
   - 是否有SQL注入风险
   - 是否有敏感信息泄露
   - 异常处理是否完整

4. **可维护性**
   - 注释是否充分
   - 日志是否规范
   - 是否便于测试

## 输出格式
### 问题清单
| 级别 | 文件:行号 | 问题描述 | 修复建议 |
|------|----------|---------|---------|
| 🔴 严重 | | | |
| 🟡 警告 | | | |
| 🟢 建议 | | | |

### 总体评价
{综合评价和改进建议}
```

### 5.2 PR描述生成

```markdown
# Prompt模板: 生成PR描述

## 角色设定
你是团队的开发工程师，正在提交一个Pull Request。

## 变更内容
```diff
{粘贴git diff输出}
```

## PR模板
```markdown
## 变更说明
{本次变更的目的和内容}

## 变更类型
- [ ] 新功能
- [ ] Bug修复
- [ ] 重构
- [ ] 文档更新

## 测试说明
{如何验证这个变更}

## 检查清单
- [ ] 代码符合规范
- [ ] 单元测试通过
- [ ] 无新增SonarQube问题
- [ ] 相关文档已更新

## 关联Issue
Closes #xxx
```

## 任务
根据diff内容，生成完整的PR描述。
```

---

## 六、文档编写阶段

### 6.1 API文档生成

```markdown
# Prompt模板: 生成API文档

## 角色设定
你是技术文档工程师，擅长编写清晰的API文档。

## 接口定义
```java
{粘贴Controller代码}
```

## 任务
生成完整的API文档，包含:
1. 接口概述
2. 请求参数说明
3. 响应结果说明
4. 错误码说明
5. 调用示例 (curl)
6. 注意事项

## 输出格式 (Markdown)
# {接口名称}

## 接口说明
{描述}

## 请求信息
- URL: `{method} {path}`
- Content-Type: application/json

## 请求参数
| 参数名 | 类型 | 必填 | 说明 |
|-------|------|------|------|

## 响应结果
```json
{示例响应}
```

## 错误码
| 错误码 | 说明 |
|-------|------|

## 调用示例
```bash
curl -X POST ...
```
```

### 6.2 技术方案文档

```markdown
# Prompt模板: 生成技术方案文档

## 角色设定
你是技术方案文档撰写专家。

## 方案信息
- 功能名称: {名称}
- 相关服务: {服务列表}
- 技术选型: {已确定的选型}

## 设计要点
{描述核心设计思路}

## 任务
生成完整的技术方案文档:

1. 概述
   - 背景
   - 目标
   - 范围

2. 架构设计
   - 整体架构
   - 模块划分
   - 交互流程

3. 详细设计
   - 接口设计
   - 数据模型
   - 核心算法

4. 非功能设计
   - 性能方案
   - 安全方案
   - 监控告警

5. 实施计划
   - 里程碑
   - 风险点

## 输出
完整的Markdown格式技术方案文档。
```

---

## 七、知识库建设

### 7.1 知识库结构

```
┌────────────────────────────────────────────────────────────────────────────┐
│                           AI 知识库层次结构                                 │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│  层级1: 架构基本法 (System Prompt基础)                                     │
│  ├── architecture-constitution.md      # 架构基本法                        │
│  ├── coding-standards.md               # 编码规范                          │
│  ├── api-guidelines.md                 # API规范                           │
│  ├── database-standards.md             # 数据库规范                         │
│  └── security-guidelines.md            # 安全规范                          │
│                                                                            │
│  层级2: 代码模板 (Few-shot示例)                                            │
│  ├── templates/                                                            │
│  │   ├── controller-template.java                                          │
│  │   ├── service-template.java                                             │
│  │   ├── repository-template.java                                          │
│  │   ├── exception-handler-template.java                                   │
│  │   └── test-template.java                                                │
│  │                                                                         │
│  层级3: 参考实现 (最佳实践)                                                 │
│  ├── reference/                                                            │
│  │   ├── user-service/          # 完整参考服务                             │
│  │   └── common-utils/          # 公共工具库                               │
│  │                                                                         │
│  层级4: ADR历史 (决策参考)                                                  │
│  └── decisions/                                                            │
│      ├── ADR-001-kafka.md                                                  │
│      ├── ADR-002-redis.md                                                  │
│      └── ...                                                               │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘
```

### 7.2 知识库使用方式

```yaml
# 在AI对话中注入知识库

方式1: System Prompt注入
  - 将架构基本法核心内容作为System Prompt
  - 适用于: 通用开发任务

方式2: 上下文注入
  - 将相关模板/示例粘贴到对话中
  - 适用于: 特定类型代码生成

方式3: RAG检索增强
  - 使用向量数据库存储知识库
  - AI自动检索相关上下文
  - 适用于: 复杂问题解答

# 示例: 生成Controller时的上下文注入
---
以下是我们的Controller模板:
```java
{粘贴controller-template.java}
```

以下是我们的编码规范:
{粘贴coding-standards.md相关章节}

请按照上述规范，为{功能}生成Controller代码。
---
```

### 7.3 知识库维护

```yaml
# 知识库维护流程
maintenance:
  更新触发:
    - 架构规范变更时
    - 发现AI输出质量问题时
    - 新增最佳实践时

  验证机制:
    - 每季度抽检AI生成代码质量
    - 对比AI输出与规范的一致性
    - 收集开发者反馈

  版本管理:
    - 知识库纳入Git版本控制
    - 变更需要Review和审批
    - 保留历史版本可追溯
```

---

## 八、效率度量

### 8.1 效率提升指标

```yaml
# AI辅助效率度量

脚手架生成:
  传统方式: 2-4小时
  AI辅助后: 15-30分钟
  提升幅度: 80%+
  度量方式: 从需求明确到项目可运行的时间

接口代码生成:
  传统方式: 2-3小时/接口 (含Controller/Service/DTO)
  AI辅助后: 30-45分钟/接口 (含Review)
  提升幅度: 70%+
  度量方式: 从接口设计到代码合并的时间

单元测试编写:
  传统方式: 1-2小时/类
  AI辅助后: 20-40分钟/类 (含Review和补充)
  提升幅度: 60%+
  度量方式: 测试代码编写时间

Code Review预审:
  传统方式: 30分钟/PR
  AI预审后: 15分钟/PR (人工复核)
  提升幅度: 50%
  度量方式: PR Review总耗时

文档生成:
  传统方式: 4-8小时/技术文档
  AI辅助后: 1-2小时 (含Review和修订)
  提升幅度: 75%+
  度量方式: 文档完成时间
```

### 8.2 质量保障指标

```yaml
# AI生成代码质量要求

代码规范符合率:
  目标: >= 95%
  度量: AI生成代码通过Checkstyle检查的比例

安全漏洞率:
  目标: 0 高危/严重
  度量: AI生成代码的安全扫描结果

测试覆盖率:
  目标: AI生成测试覆盖率 >= 80%
  度量: AI生成的单元测试对业务代码的覆盖

Review修改率:
  目标: <= 20%
  度量: AI生成代码在Review后需要修改的比例
  说明: 修改率过高说明Prompt需要优化
```

### 8.3 风险控制

```yaml
# AI辅助风险控制

禁止AI独立完成的任务:
  - 资金计算核心逻辑
  - 密钥管理和加密算法实现
  - 权限控制核心逻辑
  - 生产环境配置
  - 数据迁移脚本 (需人工验证)

必须人工Review的场景:
  - 所有AI生成的代码
  - 涉及金融交易的逻辑
  - 涉及用户数据的处理
  - 涉及外部服务调用的代码

AI幻觉防范:
  - 不使用AI不确定的库/API
  - 验证AI给出的版本号和配置
  - 对AI生成的SQL进行执行计划分析
  - 定期更新知识库中的版本信息
```

---

## 九、工具链集成

### 9.1 IDE集成

```yaml
# VS Code / IntelliJ 集成方案

推荐插件:
  - GitHub Copilot: 代码补全
  - Claude for VS Code: 对话式辅助
  - Continue: 开源AI编码助手

配置建议:
  - 将架构规范配置为项目级Context
  - 设置代码模板为Snippet
  - 配置自定义Prompt快捷键

使用场景:
  - 行内补全: 日常编码
  - 对话模式: 复杂逻辑设计
  - 解释代码: 理解遗留代码
```

### 9.2 CI/CD集成

```yaml
# AI辅助Code Review集成

# .github/workflows/ai-review.yml
name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: AI Code Review
        uses: company/ai-review-action@v1
        with:
          api_key: ${{ secrets.AI_API_KEY }}
          config_file: .ai-review.yml
          standards_file: docs/architecture/coding-standards.md

      - name: Post Review Comments
        run: |
          # 将AI审查结果发布为PR评论
```

```yaml
# .ai-review.yml 配置
review_rules:
  - name: architecture_compliance
    description: 检查架构规范符合性
    enabled: true

  - name: security_check
    description: 安全漏洞检查
    enabled: true

  - name: code_quality
    description: 代码质量检查
    enabled: true

severity_threshold: warning  # 低于此级别不阻断
```

### 9.3 文档系统集成

```yaml
# API文档自动生成

# 基于代码注释生成文档
swagger:
  generator: springdoc-openapi
  output: docs/api/openapi.json

# AI增强文档
ai_enhancement:
  enabled: true
  tasks:
    - 补充接口描述
    - 生成调用示例
    - 添加错误处理说明
```

---

## 十、最佳实践总结

### 10.1 Prompt工程最佳实践

```yaml
# 高质量Prompt的要素

1. 角色设定 (Role):
   - 明确AI扮演的角色
   - 示例: "你是熟悉我们架构规范的Java架构师"

2. 上下文注入 (Context):
   - 提供项目规范
   - 提供相关代码示例
   - 说明技术栈约束

3. 任务描述 (Task):
   - 清晰描述要完成的任务
   - 分步骤说明期望输出

4. 约束条件 (Constraints):
   - 技术约束
   - 业务约束
   - 格式约束

5. 输出格式 (Format):
   - 明确期望的输出格式
   - 提供格式示例

# 示例结构
---
## 角色
{角色设定}

## 上下文
```
{规范/示例}
```

## 任务
{任务描述}

## 约束
- {约束1}
- {约束2}

## 输出格式
{格式说明}
---
```

### 10.2 迭代优化策略

```yaml
# Prompt迭代优化流程

1. 初始Prompt:
   - 使用基础模板
   - 观察输出质量

2. 问题识别:
   - 输出不符合规范?
   - 缺少必要内容?
   - 格式不正确?

3. 针对性优化:
   - 添加更多上下文
   - 细化约束条件
   - 提供更多示例

4. 验证效果:
   - 多次测试
   - 对比优化前后

5. 沉淀模板:
   - 记录有效Prompt
   - 加入知识库
```

### 10.3 团队协作

```yaml
# AI辅助团队协作

Prompt模板共享:
  - 建立团队Prompt库
  - 定期分享有效Prompt
  - 新人培训使用方法

知识库共建:
  - 指定维护责任人
  - 定期更新和Review
  - 收集使用反馈

质量反馈:
  - 建立反馈渠道
  - 记录AI输出问题
  - 持续优化改进

培训机制:
  - 新人AI工具培训
  - 定期分享会
  - 最佳实践案例
```
