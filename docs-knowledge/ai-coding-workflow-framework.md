# AI Coding 研发流程体系

**版本**: 2.1
**创建日期**: 2025-12-01
**更新日期**: 2025-12-01
**作者**: 架构团队
**状态**: 设计中

---

## 1. 概述

### 1.1 设计目标

本文档定义了一套以 **SDD（规范驱动开发）** 和 **TDD（测试驱动开发）** 为核心驱动力的 AI Coding 研发流程体系，结合多级知识空间架构和统一工具链基础设施，实现从"人工编码"到"AI协同编码"的研发模式转型。

### 1.2 核心理念

```
┌─────────────────────────────────────────────────────────────────┐
│                    AI Coding 研发流程体系                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│   │  SDD驱动    │ ←→ │  TDD驱动    │ ←→ │  AI协同     │        │
│   │  规范先行   │    │  测试先行   │    │  人机结对   │        │
│   └─────────────┘    └─────────────┘    └─────────────┘        │
│          ↑                  ↑                  ↑                │
│          └──────────────────┼──────────────────┘                │
│                             │                                   │
│   ┌─────────────────────────┴─────────────────────────┐        │
│   │              多级知识空间 + 统一工具链              │        │
│   │         L0企业级 → L1项目级 → L2仓库级             │        │
│   └───────────────────────────────────────────────────┘        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 核心原则

| 原则 | 说明 |
|------|------|
| **规范驱动** | 先有设计规范，后有代码实现，AI直接消费设计规范 |
| **测试先行** | 先写测试定义行为，再由AI生成实现代码 |
| **知识分层** | 企业→项目→仓库三层知识架构，自底向上聚合 |
| **工具统一** | 统一的AI工具链和开发环境，降低认知负担 |
| **持续改进** | 数据驱动的效能度量和流程优化 |

---

## 2. 流程重塑

### 2.1 SDD 规范驱动开发【核心】

#### 2.1.1 设计先行原则

SDD的核心理念是"**设计即约束**"——通过清晰的功能规格文档约束AI的代码生成行为，避免过度实现和功能蔓延。

**功能规格文档结构**：

```markdown
# 功能规格: [功能名称]

## 1. 需求详细说明
- 业务背景
- 用户故事
- 验收标准

## 2. 技术设计文档
- 架构设计
- 数据模型
- 接口定义

## 3. 接口契约
- API规范 (OpenAPI/GraphQL)
- 请求/响应示例
- 错误码定义

## 4. 约束条件
- 技术栈限定
- 代码行数控制
- 排除功能清单
```

#### 2.1.2 SDD 工作流程

基于 Speckit 的标准化工作流：

```
┌──────────────────────────────────────────────────────────────┐
│                    SDD 工作流程                               │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐        │
│  │   specify   │ → │    plan     │ → │    tasks    │        │
│  │  自然语言   │   │  实施计划   │   │  可执行任务  │        │
│  │  →功能规格  │   │  →设计文档  │   │  →任务列表   │        │
│  └─────────────┘   └─────────────┘   └─────────────┘        │
│                                              ↓               │
│                                      ┌─────────────┐        │
│                                      │  implement  │        │
│                                      │  任务→代码  │        │
│                                      └─────────────┘        │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

**工作流命令**：

| 命令 | 功能 | 输入 | 输出 |
|------|------|------|------|
| `/speckit.specify` | 创建功能规格 | 自然语言描述 | spec.md |
| `/speckit.plan` | 生成实施计划 | spec.md | plan.md |
| `/speckit.tasks` | 生成任务列表 | plan.md | tasks.md |
| `/speckit.implement` | 执行代码实现 | tasks.md | 代码文件 |
| `/speckit.analyze` | 跨产物分析 | spec/plan/tasks | 一致性报告 |
| `/speckit.clarify` | 需求澄清 | spec.md | 澄清问题 |

#### 2.1.3 知识库集成增强

**各阶段知识库读取**：

| 阶段 | 知识库层级 | 读取内容 | 用途 |
|------|-----------|----------|------|
| **specify** | L1 项目级 | glossary.md, domain-model.md | 术语规范、实体识别 |
| **specify** | L2 仓库级 | context.md, overview.md | 模块边界、避免重复 |
| **plan** | L0 企业级 | architecture-principles.md | 架构合规检查 |
| **plan** | L1 项目级 | tech-stack.md, ADR-*.md | 技术选型、ADR一致性 |
| **plan** | L2 仓库级 | module_tree.json, {module}.md | 路径规范、组件复用 |
| **tasks** | L2 仓库级 | module_tree.json | 文件路径验证 |
| **implement** | L2 仓库级 | {module}.md | 代码模式参考 |

#### 2.1.4 架构合规检查

在 `/speckit.plan` 的 Phase 0 和 Phase 1 之间强制执行架构合规检查：

**九大原则检查矩阵**：

| 原则 | 检查项 | 严重级别 |
|------|--------|----------|
| I. TDD | 测试策略、覆盖率目标 | CRITICAL |
| III. 微服务架构 | 分层结构、技术栈合规 | CRITICAL |
| IV. 安全优先 | 输入校验、审计日志 | CRITICAL |
| V. RESTful | API设计规范 | HIGH |
| VI. 生产就绪 | 错误处理、事务管理 | HIGH |
| VIII. 简洁性 | YAGNI、依赖管理 | MEDIUM |
| IX. 事件驱动 | 事件监听、幂等性 | HIGH |

**合规检查输出**：

```markdown
## Architecture Compliance Check

| 原则 | 适用性 | 检查结果 | 说明 |
|------|--------|----------|------|
| I. TDD | ✓ | ✅ | 已规划单元测试和集成测试 |
| III. 微服务 | ✓ | ⚠️ | 技术栈合规，分层需调整 |
| IV. 安全 | ✓ | ✅ | 已规划输入校验和审计日志 |

**处理规则**: ✅全部合规→继续 | ⚠️需调整→修改后继续 | ❌违规→阻止流程
```

#### 2.1.5 AI 协同 SDD 实践

**Prompt 模板化**：

```markdown
## 任务
根据以下规格文档实现 [功能名称]

## 约束条件
- 技术栈: [具体技术栈]
- 代码行数: 不超过 [N] 行
- 排除功能: [明确排除列表]

## 输入规格
[粘贴 spec.md 相关内容]

## 输出要求
- 遵循项目编码规范
- 包含单元测试
- 提供使用示例
```

**防止 AI 过度联想**：

| 策略 | 说明 | 示例 |
|------|------|------|
| **负向提示** | 明确列出不需要的功能 | "不需要：密码重置、邮箱验证、OAuth" |
| **领域边界** | 定义功能边界 | "仅限用户基础信息CRUD，不涉及权限" |
| **单一事实源** | 限制输入输出 | "输入：用户名+密码，输出：JWT token" |

**渐进式迭代**：

```
第1轮: 核心数据模型
    ↓
第2轮: 基础CRUD接口
    ↓
第3轮: 业务逻辑层
    ↓
第4轮: 验证和错误处理
    ↓
第5轮: 测试用例补充
```

### 2.2 TDD 测试驱动开发【核心】

#### 2.2.1 TDD 三定律

1. **先写失败测试**：在编写任何生产代码之前，先编写一个失败的单元测试
2. **仅写足够代码**：只编写刚好能让测试通过的生产代码
3. **重构保持测试**：重构代码时确保所有测试仍然通过

#### 2.2.2 红灯-绿灯-重构循环

```
┌─────────────────────────────────────────────────────┐
│              TDD 循环                                │
├─────────────────────────────────────────────────────┤
│                                                     │
│      ┌─────────┐                                    │
│      │  红灯   │ ← 编写失败测试                      │
│      │  RED    │                                    │
│      └────┬────┘                                    │
│           │                                         │
│           ▼                                         │
│      ┌─────────┐                                    │
│      │  绿灯   │ ← 最小代码通过测试                  │
│      │  GREEN  │                                    │
│      └────┬────┘                                    │
│           │                                         │
│           ▼                                         │
│      ┌─────────┐                                    │
│      │  重构   │ ← 优化设计保持绿灯                  │
│      │ REFACTOR│                                    │
│      └────┬────┘                                    │
│           │                                         │
│           └─────────→ 回到红灯                       │
│                                                     │
└─────────────────────────────────────────────────────┘
```

#### 2.2.3 AI 优先 TDD 流程

将 AI 深度集成到 TDD 流程中：

```
┌─────────────────────────────────────────────────────────────┐
│                AI 优先 TDD 流程                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Step 1: 人工编写测试签名和意图                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ describe('用户注册', () => {                         │   │
│  │   it('应该成功注册新用户', () => {                    │   │
│  │     // 意图: 验证邮箱+密码注册流程                    │   │
│  │   });                                                │   │
│  │ });                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  Step 2: AI 生成完整测试用例                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ it('应该成功注册新用户', async () => {               │   │
│  │   const user = { email: 'test@example.com', ... };   │   │
│  │   const result = await registerUser(user);           │   │
│  │   expect(result.success).toBe(true);                 │   │
│  │   expect(result.user.id).toBeDefined();              │   │
│  │ });                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  Step 3: AI 编写通过测试的实现代码                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ async function registerUser(userData) {              │   │
│  │   // AI生成的实现代码                                │   │
│  │   const user = await User.create(userData);          │   │
│  │   return { success: true, user };                    │   │
│  │ }                                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  Step 4: 人工审查和验证                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.4 测试金字塔

```
                    ┌─────────┐
                    │  E2E    │  10%
                    │  测试   │
                ┌───┴─────────┴───┐
                │   集成测试       │  30%
            ┌───┴─────────────────┴───┐
            │       单元测试           │  60%
            └─────────────────────────┘
```

**测试覆盖率要求**：≥80%

### 2.3 AI 协同开发流程

#### 2.3.1 需求阶段

| 活动 | 负责人 | AI参与方式 | 产出 |
|------|--------|-----------|------|
| 需求分析 | 产品经理 | LLM分析原始需求 | 用户故事草稿 |
| 任务拆解 | 技术负责人 | AI辅助拆解 | 任务列表 |
| 技术方案 | 架构师 | Vibe-Driven Development | 技术规格 |

**Vibe-Driven Development**：

```
高阶概念 (Vibe)
    ↓ AI对话迭代
技术规格 (Spec)
    ↓ AI对话迭代
实现路径 (Path)
```

#### 2.3.2 开发阶段

**人机结对编程规范**：

| 角色 | 职责 |
|------|------|
| **AI** | 样板代码生成、API调用实现、单元测试生成、文档生成 |
| **人** | 业务逻辑设计、架构决策、代码审查、最终验收 |

**从规格生成代码**：

```
OpenAPI/Swagger  →  API客户端 + 服务器路由
GraphQL Schema   →  类型定义 + Resolver骨架
数据库DDL       →  ORM模型 + Repository层
```

#### 2.3.3 Code Review 阶段

**Code Review 的核心目的**：

1. **让代码更加统一、规范、易维护**：通过统一的代码风格和规范，降低维护成本
2. **方便开发人员互相学习经验，达到知识共享**：促进团队整体技术水平提升
3. **帮助开发人员跳出固定思维，得出最优解决思路**：多人Review从不同角度审视代码
4. **从可运行到可重用**：使代码不仅能完成功能，还具备良好的可重用性和扩展性

**双层 CR 机制**：

```
┌─────────────────────────────────────────────────────────────┐
│                    双层 CR 机制                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  第一层: AI 自动化 Review                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 代码风格检查                                       │   │
│  │ • 潜在 Bug 检测                                      │   │
│  │ • 最佳实践建议                                       │   │
│  │ • 安全漏洞扫描                                       │   │
│  │ • 性能问题识别                                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  第二层: 人类 Reviewer                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 架构一致性                                         │   │
│  │ • 业务逻辑正确性                                     │   │
│  │ • 系统可扩展性                                       │   │
│  │ • 设计模式合理性                                     │   │
│  │ • 领域建模正确性                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Code Review 完整流程**：

```
1. 开发者提交代码
       ↓
2. 自我 Review（开发者自查基本规范）
       ↓
3. AI 自动化 Review（CI触发）
       ↓
4. 同行 Review（团队成员审查）
       ↓
5. 讨论与修改（针对意见修改）
       ↓
6. 二次 Review（重大问题修改后）
       ↓
7. 合并代码
```

**Code Review 检查清单**：

| 检查维度 | 检查项 |
|----------|--------|
| **功能性** | 代码是否实现需求功能、边界条件处理、逻辑错误检查 |
| **设计性** | 是否符合SOLID原则、职责划分合理性、避免过度设计 |
| **代码质量** | 可读性、命名清晰度、注释充分性 |
| **性能安全** | 性能瓶颈、资源释放、安全漏洞 |

---

## 3. 代码设计规范

### 3.1 三阶段编程方法论

优秀的代码设计需要经历三个阶段：**分析 → 设计 → 打磨**

```
┌─────────────────────────────────────────────────────────────┐
│                    三阶段编程                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐       │
│  │   分析阶段   │ → │   设计阶段   │ → │   打磨阶段   │       │
│  │             │   │             │   │             │       │
│  │ • 分析需求   │   │ • 分配职责   │   │ • 选择模式   │       │
│  │ • 识别实体   │   │ • GRASP原则  │   │ • 提高可读   │       │
│  │ • 找核心概念 │   │ • 确保清晰   │   │ • 优化维护   │       │
│  └─────────────┘   └─────────────┘   └─────────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**分析阶段**：
- 不要急于实现功能，避免陷入事务脚本模式（面向过程）
- 分析需求的本质目的
- 识别完成功能需要的核心实体
- 核心是"**找实体**"

**设计阶段**：
- 将职责合理分配到各个实体上
- 运用 GRASP 原则指导设计
- 确保职责分配的合理性和清晰性

**打磨阶段**：
- 选择合适的设计模式实现
- 提高代码的可读性和可维护性
- 使用模板模式处理通用业务流程

### 3.2 SOLID 设计原则

SOLID 是面向对象设计的五大基本原则，是编写高质量代码的基石：

#### 3.2.1 单一职责原则 (SRP)

**定义**：一个类只负责完成一个职责或功能，不应存在多于一种导致类变更的原因。

**优势**：
- 提高类的内聚性
- 降低代码耦合性
- 使代码更易于理解和维护

**注意**：不要过度拆分，否则会降低内聚性，影响可维护性

#### 3.2.2 开放-关闭原则 (OCP)

**定义**：对扩展开放，对修改关闭。添加新功能应通过扩展代码而非修改已有代码。

**实现方式**：
- 使用多态
- 依赖注入
- 基于接口而非实现编程
- 应用设计模式（装饰、策略、模板、职责链、状态等）

#### 3.2.3 里氏替换原则 (LSP)

**定义**：子类对象能够替换程序中父类对象出现的任何地方，并保证原有程序逻辑行为不变。

**核心要求**：
- 子类可以扩展父类功能
- 子类不能改变父类原有功能
- 父类已实现的方法是规范和契约

#### 3.2.4 接口隔离原则 (ISP)

**定义**：调用方不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

**判断标准**：如果调用者只使用部分接口或接口的部分功能，说明接口设计不够职责单一。

#### 3.2.5 依赖反转原则 (DIP)

**定义**：
- 高层模块不应该依赖低层模块，二者都应该依赖其抽象
- 抽象不应该依赖细节，细节应该依赖抽象

**实践**：面向接口编程，而不是面向实现编程

#### 3.2.6 其他重要原则

| 原则 | 说明 |
|------|------|
| **迪米特法则** | 一个对象应该对其他对象保持最少的了解，降低耦合度 |
| **合成复用原则** | 尽量使用组合/聚合方式，而不是使用继承 |

### 3.3 设计模式应用指南

设计模式是经过验证的问题解决方案，核心思想是"**找到变化，封装变化**"。

#### 创建型模式

| 模式 | 说明 | 适用场景 |
|------|------|----------|
| **单例** | 一个类只允许创建一个实例 | 无状态/全局唯一/控制资源访问 |
| **工厂** | 创建相关对象，使用者不关心具体实现类 | 分离对象创建和使用 |
| **建造者** | 创建复杂对象，通过设置可选参数定制化 | 构造参数较多且多数可选 |
| **原型** | 通过复制已有对象创建新对象 | 对象创建成本大且差别不大 |

#### 结构型模式

| 模式 | 说明 | 适用场景 |
|------|------|----------|
| **代理** | 不改变原始类情况下，通过代理类附加功能 | 监控、缓存、限流、事务、RPC |
| **装饰者** | 不改变原始类情况下，通过组合动态扩展功能 | 动态扩展类的功能 |
| **适配器** | 不改变原始类情况下，使其适配新接口 | 复用现有类，但接口不适配 |
| **桥接** | 多个独立变化维度时，通过组合独立扩展 | 存在多维度继承体系 |
| **门面** | 为子系统定义更高层接口，使其更易使用 | 解决接口复用性与易用性矛盾 |
| **组合** | 将对象组合成树形结构，统一处理 | 满足部分-整体树形结构 |
| **享元** | 运用共享技术支持大量细粒度对象 | 大量对象且字段取值范围固定 |

#### 行为型模式

| 模式 | 说明 | 适用场景 |
|------|------|----------|
| **观察者** | 主题对象状态变化时通知所有观察者 | 解耦事件创建者与接收者 |
| **模板** | 定义算法骨架，延迟某些步骤到子类 | 解决复用与扩展问题 |
| **策略** | 封装一组算法，使其可互相替换 | 消除if-else，解耦策略定义/创建/使用 |
| **状态** | 对象内部状态改变时改变其行为 | 分离对象状态与行为 |
| **职责链** | 对象连成链，请求沿链传递直到被处理 | 解耦请求发送者与接收者 |
| **迭代器** | 顺序访问集合元素，不暴露内部表示 | 解耦集合内部表示与遍历访问 |
| **命令** | 将请求封装成命令对象，控制执行过程 | 异步、延迟、排队、撤销、存储命令 |

---

## 4. 编码技巧规范

### 4.1 方法级优化技巧

#### 4.1.1 提炼方法与意图导向编程

**适用场景**：
- 多个方法代码重复
- 方法中代码过长（一般不超过80行）
- 方法中语句不在同一抽象层级

**意图导向编程原则**：
- 将处理流程和具体实现分离
- 把问题分解为一系列功能性步骤
- 假定功能步骤已实现，先组织整体流程
- 最后再实现各个具体方法

```
示例 - 交易处理流程：
1. 解析交易字符串
2. 转换为词汇元素数组
3. 标准化每个词汇
4. 根据规模选择提交算法
5. 返回提交结果
```

#### 4.1.2 其他方法级技巧

| 技巧 | 说明 |
|------|------|
| **以函数对象取代函数** | 将大型函数放进单独对象中，局部变量变成对象字段 |
| **引入参数对象** | 方法参数较多时，将参数封装为参数对象 |
| **移除对参数的赋值** | 有返回值的方法不应有副作用，避免修改参数值 |
| **引入解释性变量** | 将复杂表达式结果放入临时变量，用变量名解释用途 |
| **try-catch内部代码抽成方法** | 保持核心逻辑清晰 |

### 4.2 条件判断优化

#### 4.2.1 使用卫语句替代嵌套条件

**原则**：把复杂的条件表达式拆分成多个条件表达式，减少嵌套。

```
// 反例：多层嵌套
if (condition1) {
    if (condition2) {
        if (condition3) {
            // 核心逻辑
        }
    }
}

// 正例：卫语句
if (!condition1) return;
if (!condition2) return;
if (!condition3) return;
// 核心逻辑
```

**优势**：降低复杂度、提高可读性、核心逻辑更清晰

#### 4.2.2 使用多态替代条件判断

**适用场景**：当存在根据对象类型选择不同行为的条件表达式时

**实现方式**：
- 将每个分支放进子类内的覆写方法
- 将原始函数声明为抽象函数
- 利用多态机制自动选择正确的实现

### 4.3 异常处理规范

#### 4.3.1 使用异常替代返回错误码

**原则**：非正常业务状态使用抛出异常方式，而不是返回错误码。

**实施要点**：
- 通过最上层统一处理异常，转换成标准返回码
- 不要使用异常处理正常的业务流程控制
- 尽量使用标准异常
- 避免在 finally 语句块中抛出异常
- finally 块中只做关闭资源类操作

**典型模式**：
```
1. 业务逻辑层抛出业务异常
       ↓
2. 服务层简单调用，不处理异常
       ↓
3. 控制层（Controller/Filter）统一拦截处理异常
```

#### 4.3.2 引入断言

**使用原则**：
- 只用于检查"一定必须为真"的条件
- 不用于检查"应该为真"的条件
- 如果断言条件不满足，代码仍能正常运行，则去掉断言

### 4.4 空值处理

#### 4.4.1 引入 Null 对象或特殊对象

**问题**：频繁的判空操作影响代码美观和可读性，增加 Bug 几率

**解决方案**：
- 创建一个特殊的空对象类
- 空对象提供默认的安全行为
- 使用 Optional 优雅处理

**空指针产生原因**：
- 数据库查询结果为 null
- 集合/数组访问越界
- 对象方法调用时对象为 null

### 4.5 类设计优化

#### 4.5.1 提炼类

**适用场景**：
- 类包含大量数据和函数
- 逻辑复杂不易理解
- 职责不断增加

**判断依据**：
- 某些数据和方法总是一起出现
- 某些数据经常同时变化
- 子类化只影响类的部分特性

**原则**：高内聚低耦合

#### 4.5.2 组合优先于继承

**继承的局限性**：
- 打破封装性
- 子类依赖父类实现细节
- 父类变化可能破坏子类

**组合的优势**：
- 通过私有域引用现有类实例
- 不依赖现有类实现细节
- 更加稳固和灵活

**使用场景判断**：
- 仅当存在真正的"is-a"关系时使用继承
- 包内部使用继承是安全的
- 其他情况优先考虑组合

#### 4.5.3 接口优于抽象类

**接口优势**：
- 现有类可以轻松实现新接口
- 是定义混合类型的理想选择
- 允许构造非层次结构的类型框架

**最佳实践**：接口 + 骨架实现类（模板方法设计模式）

### 4.6 泛型使用规范

| 规范 | 说明 |
|------|------|
| **优先考虑泛型** | 编译时类型安全、避免类型转换 |
| **不要使用原生态类型** | 使用原生态类型会失去泛型优势 |
| **消除非受检警告** | 每条警告都表示可能的 ClassCastException |
| **PECS 原则** | Producer-Extends, Consumer-Super |

### 4.7 代码质量提升技巧

| 技巧 | 说明 |
|------|------|
| **优先使用模板/工具类** | 减少重复代码，专注业务逻辑 |
| **分离对象的创建与使用** | 工厂模式、构建器模式、依赖注入 |
| **可访问性最小化** | 尽可能使每个类和成员不被外界访问 |
| **可变性最小化** | 不可变类简单、线程安全、可自由共享 |
| **静态成员类优于非静态成员类** | 非静态成员类会隐式持有外部类引用 |

### 4.8 参数校验与返回规范

#### 4.8.1 优雅地参数校验

**格式校验**：
- 使用 hibernate-validator 框架
- 在实体类上使用 @NotBlank、@NotNull 等注解
- Controller 方法上使用 @Valid 注解

**业务校验**：
- 自定义校验注解
- 实现 ConstraintValidator 接口

#### 4.8.2 统一返回值

**原则**：
- 所有接口使用统一的返回值结构
- 包含状态码、消息、数据等标准字段
- 便于接口调用方统一解析

#### 4.8.3 统一异常处理

**实现方式**：
- 使用 @ControllerAdvice
- 使用 @ExceptionHandler
- 统一转换异常为标准返回格式

### 4.9 并发编程规范

| 规范 | 说明 |
|------|------|
| **涉及线程间可见性加 volatile** | 保证线程间的可见性 |
| **减小锁使用范围** | 只给需要加锁的代码加锁，在 finally 中释放锁 |
| **分布式锁规范** | 必须设置过期时间和获取锁的超时时间 |

### 4.10 性能优化技巧

| 技巧 | 说明 |
|------|------|
| **集合指定初始化大小** | 避免扩容消耗性能 |
| **不要使用 BeanUtils 拷贝属性** | 基于反射性能较差，使用 MapStruct |
| **使用 StringBuilder 拼接字符串** | 减少对象创建 |
| **不循环调用数据库** | 批量查询 + 转换为 Map + 内存匹配 |
| **用业务代码代替多表 join** | 在应用层进行数据关联 |
| **远程接口调用设置超时时间** | 防止线程"卡死" |

### 4.11 其他最佳实践

| 实践 | 说明 |
|------|------|
| **尽量使用工具类** | CollectionUtils、StringUtils、Hutool 等 |
| **面向接口编程** | 引用父类或抽象，而非实现 |
| **魔法值用常量表示** | 提高可读性，便于维护 |
| **有类型区分时定义好枚举** | 避免魔法数字，提供类型安全 |
| **写好代码注释** | 解释为什么这样做，而不是怎么做 |

---

## 5. 多级知识空间

### 5.1 三层架构体系

```
┌─────────────────────────────────────────────────────────────┐
│                    企业级 (L0)                              │
│              (Enterprise Standards)                         │
│   ┌──────────────┐ ┌──────────────┐ ┌──────────────┐       │
│   │  技术宪法     │ │  编码规范     │ │  技术雷达     │       │
│   └──────────────┘ └──────────────┘ └──────────────┘       │
├─────────────────────────────────────────────────────────────┤
│                    项目级 (L1)                              │
│              (Project Knowledge)                            │
│   ┌──────────────┐ ┌──────────────┐ ┌──────────────┐       │
│   │  业务领域     │ │  服务目录     │ │  架构决策     │       │
│   │  领域模型     │ │  依赖拓扑     │ │  数据流图     │       │
│   └──────────────┘ └──────────────┘ └──────────────┘       │
├─────────────────────────────────────────────────────────────┤
│                    仓库级 (L2)                              │
│              (Repository Context)                           │
│   ┌──────────────┐ ┌──────────────┐ ┌──────────────┐       │
│   │  仓库A        │ │  仓库B        │ │  仓库C        │       │
│   │  context.md  │ │  context.md  │ │  context.md  │       │
│   └──────────────┘ └──────────────┘ └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 L0 企业级知识库

**职责**：企业级强制规范、跨项目统一标准

**目录结构**：

```
enterprise-standards/
├── constitution/               # 技术宪法
│   ├── architecture-principles.md
│   ├── security-baseline.md
│   └── compliance-requirements.md
├── standards/                  # 编码规范
│   ├── coding-standards/
│   │   ├── java.md
│   │   ├── typescript.md
│   │   └── python.md
│   ├── api-design-guide.md
│   └── testing-standards.md
└── technology-radar/           # 技术雷达
    ├── adopt.md               # 推荐采用
    ├── trial.md               # 试用阶段
    ├── assess.md              # 评估阶段
    └── hold.md                # 暂缓使用
```

**维护方式**：架构委员会统一维护

### 5.3 L1 项目级知识库

**职责**：跨仓库业务知识、项目级架构决策、AI定期聚合

**目录结构**：

```
project-knowledge/
├── README.md                   # 项目总览
├── BUSINESS.md                 # 业务知识入口
├── ARCHITECTURE.md             # 架构知识入口
│
├── business/                   # 业务领域知识
│   ├── domain-model.md        # 领域模型
│   ├── glossary.md            # 术语词典
│   ├── workflows/             # 业务流程
│   │   ├── user-registration.md
│   │   └── order-lifecycle.md
│   └── rules.md               # 业务规则
│
├── architecture/               # 架构知识
│   ├── service-catalog.md     # 服务目录
│   ├── repo-map.md            # 仓库地图
│   ├── data-flow.md           # 数据流图
│   ├── tech-stack.md          # 技术栈
│   └── decisions/             # 架构决策记录
│       ├── ADR-001-microservices.md
│       └── ADR-002-event-driven.md
│
├── standards/                  # 项目规范（继承L0）
│   ├── coding.md
│   ├── api.md
│   └── testing.md
│
└── aggregated/                 # AI聚合区（自动生成）
    ├── last-updated.json
    ├── repo-summaries/        # 各仓库摘要
    ├── service-topology.md    # 服务拓扑
    ├── cross-repo-patterns.md # 跨仓库模式
    └── improvement-suggestions.md
```

**维护方式**：AI聚合 + 人工审核

### 5.4 L2 仓库级知识库

**设计原则**：

- **极简原则**：只保留仓库特有信息
- **继承原则**：通用规范从上层继承
- **自动化原则**：code-derived 由 AI 自动生成

**目录结构**：

```
{repo}/
├── CLAUDE.md                    # AI入口（必须）
└── .knowledge/
    ├── context.md               # 仓库上下文（必须，人工维护）
    ├── decisions.md             # 重要决策记录（可选）
    └── code-derived/            # 代码衍生文档（AI自动生成）
        ├── metadata.json        # 生成元信息
        ├── overview.md          # 仓库概览
        ├── module_tree.json     # 模块依赖树
        └── {module-name}.md     # 各模块详细文档
```

**context.md 模板**：

```markdown
# 仓库上下文: {repo-name}

## 1. 仓库定位
- **职责**: [一句话描述核心职责]
- **所属项目**: [项目名]
- **上游依赖**: [依赖的仓库/服务]
- **下游消费者**: [谁调用我]

## 2. 技术栈
- 语言: Java 17
- 框架: Spring Boot 3.2
- 数据库: PostgreSQL 14
- 特殊依赖: Redis, RabbitMQ

## 3. 核心模块
| 模块 | 职责 | 主要类 |
|------|------|--------|
| user-api | 用户接口层 | UserController |
| user-service | 业务逻辑层 | UserService |
| user-repository | 数据访问层 | UserRepository |

## 4. 本仓库特有规则
- 用户ID必须使用雪花算法生成
- 密码必须加密存储，使用 bcrypt
- 所有接口需要支持幂等性

## 5. 快速链接
- 项目知识库: [链接]
- API文档: [链接]
- 数据库ER图: [链接]
```

**code-derived 代码衍生文档**：

| 文件 | 说明 | 生成方式 |
|------|------|----------|
| `metadata.json` | 生成元信息 | AI扫描代码自动生成 |
| `overview.md` | 仓库概览、端到端架构图 | AI分析代码结构生成 |
| `module_tree.json` | 模块依赖树 | AI分析import/require生成 |
| `{module}.md` | 模块详细文档 | AI分析模块代码生成 |

### 5.5 信息流向机制

```
┌─────────────────────────────────────────────────────────────┐
│                    信息流向                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  自底向上生成 (Upward Aggregation)                          │
│  ─────────────────────────────────                          │
│  仓库级 (L2)  ───AI定期聚合───→  项目级 (L1)  ───→  企业级  │
│                                                             │
│  • 收集 context.md 变更                                     │
│  • 收集 code-derived 文档                                   │
│  • 分析变更影响                                             │
│  • 生成聚合报告                                             │
│  • 更新项目文档                                             │
│                                                             │
│  自顶向下继承 (Downward Inheritance)                        │
│  ─────────────────────────────────                          │
│  企业级 (L0)  ───规范传递───→  项目级 (L1)  ───→  仓库级    │
│                                                             │
│  • 编码规范继承                                             │
│  • 技术选型约束                                             │
│  • 安全基线要求                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.6 AI 聚合机制

**聚合配置** (`aggregation/config.yaml`)：

```yaml
version: "2.0"

schedule:
  type: weekly
  day: monday
  time: "02:00"

repositories:
  github_org:
    org: "your-org"
    repos:
      - name: "user-service"
        knowledge_path: ".knowledge/context.md"
        code_derived_path: ".knowledge/code-derived/"
      - name: "order-service"
        knowledge_path: ".knowledge/context.md"
        code_derived_path: ".knowledge/code-derived/"

knowledge_sources:
  context:
    path: ".knowledge/context.md"
    type: "manual"
    required: true
  code_derived:
    path: ".knowledge/code-derived/"
    type: "auto-generated"
    required: false

tasks:
  collect_context:
    description: "收集各仓库 context.md 的变更"
  analyze_impact:
    description: "分析变更对项目文档的影响"
  update_docs:
    description: "更新项目级文档"
    mode: "suggest"

review:
  auto_merge:
    enabled: true
    conditions:
      - "only_additions"
      - "confidence_score >= 0.9"
  manual_review:
    reviewers: ["@architect", "@tech-lead"]
    required_for:
      - "architecture/*"
      - "business/domain-*.md"
```

**聚合流程**：

```
1. 收集阶段
   ├── 克隆/拉取各子仓库
   ├── 读取 .knowledge/context.md
   ├── 读取 .knowledge/code-derived/
   ├── 与上次快照对比，识别变更
   └── 生成变更列表

2. 分析阶段 (AI驱动)
   ├── 变更分类 (API/领域模型/架构/配置)
   ├── 影响分析 (哪些项目文档需更新)
   ├── 冲突检测 (多仓库修改同一概念)
   └── 生成分析报告

3. 更新阶段 (AI驱动)
   ├── 根据分析结果更新项目文档
   ├── 保持文档风格一致
   ├── 标注变更来源
   └── 验证交叉引用

4. 审核阶段
   ├── 自动创建 PR
   ├── 低风险变更自动合并
   ├── 高风险变更人工审核
   └── 发送通知 (Slack/邮件)
```

### 5.7 SpecKit 知识库配置

**配置文件** (`.specify/knowledge-config.yaml`)：

```yaml
knowledge_sources:
  enterprise:
    enabled: true
    path: "../docs-knowledge/enterprise-standards"
  project:
    enabled: true
    path: "../docs-knowledge/project-xxx"
  repository:
    context: ".knowledge/context.md"
    code_derived: ".knowledge/code-derived/"

architecture_compliance:
  enabled: true
  strict_mode: true  # true: 违规阻止流程
  skip_principles: []  # 可跳过的原则（需理由）
```

**错误代码**：

| 代码 | 含义 | 处理 |
|------|------|------|
| ARCH-001 | 违反企业架构原则 | 阻止流程 |
| ARCH-002 | ADR 冲突 | 阻止流程 |
| ARCH-003 | 模块边界越界 | 警告 |
| KNOW-001 | 知识库不可访问 | 跳过检查 |

---

## 6. 统一工具链

### 6.1 AI 编码工具

#### 6.1.1 核心 IDE 和 Agent

| 工具 | 定位 | 使用场景 |
|------|------|----------|
| **Claude Code CLI** | Base Agent | 主力开发工具，支持MCP集成 |
| **Cursor** | AI编辑器 | 日常编码，代码补全 |
| **GitHub Copilot** | 代码补全 | 辅助编码，代码建议 |

#### 6.1.2 Agent 架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Agent 架构                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                 Claude Code (Base Agent)             │   │
│  │  • 子Agent调度                                       │   │
│  │  • MCP集成                                           │   │
│  │  • 通用开发工具                                      │   │
│  │  • 上下文压缩                                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│          ┌───────────────┼───────────────┐                 │
│          ▼               ▼               ▼                 │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐       │
│  │ Coding Agent │ │  Test Agent  │ │ Deploy Agent │       │
│  └──────────────┘ └──────────────┘ └──────────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 开发工具集成 (MCP)

通过 MCP（Model Context Protocol）将分散的工具集成：

| MCP Server | 功能 | 触发场景 |
|------------|------|----------|
| **Context7** | 官方文档查询 | 框架API、库使用方法 |
| **Sequential** | 复杂推理 | 调试、系统设计 |
| **Serena** | 语义理解 | 符号操作、项目导航 |
| **Playwright** | 浏览器测试 | E2E测试、UI验证 |

### 6.3 代码理解能力

**三层代码理解**：

| 层级 | 方案 | 目的 |
|------|------|------|
| **目标仓库定位** | 知识库RAG | 快速定位目标仓库 |
| **跨仓库依赖召回** | RAG + Git增量更新 | 召回依赖代码 |
| **工作区代码理解** | 文本搜索 + AST | 精确理解当前代码 |

### 6.4 长期记忆系统

```
┌─────────────────────────────────────────────────────────────┐
│                    长期记忆系统                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐ │
│  │ 记忆提取 │ → │ 记忆存储 │ → │ 记忆召回 │ → │跨会话复用│ │
│  │          │   │          │   │          │   │          │ │
│  │ 开发者与 │   │ 结构化   │   │ 相似场景 │   │ 知识持续 │ │
│  │ Agent对话│   │ 索引存储 │   │ 匹配召回 │   │ 积累     │ │
│  └──────────┘   └──────────┘   └──────────┘   └──────────┘ │
│                                                             │
│  效果对比:                                                  │
│  • 未接入记忆: 5-10轮对话修正                               │
│  • 接入记忆: 1-3轮对话                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.5 云端沙箱

**设计要点**：

| 特性 | 说明 |
|------|------|
| **标准化环境** | 每个Agent会话分配独立沙箱 |
| **无状态化** | 会话与沙箱解耦，支持水平扩容 |
| **共享存储** | 会话状态存储在共享存储中 |
| **统一网关** | 解决安全和监管问题 |

### 6.6 质量工具链

```
┌─────────────────────────────────────────────────────────────┐
│                    质量工具链                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  静态分析          安全扫描           测试框架              │
│  ┌──────────┐     ┌──────────┐      ┌──────────┐           │
│  │ ESLint   │     │ Snyk     │      │ Jest     │           │
│  │ SonarQube│     │ AI SAST  │      │ Pytest   │           │
│  │ DeepCode │     │ 敏感信息 │      │Playwright│           │
│  └──────────┘     └──────────┘      └──────────┘           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.7 CI/CD 集成

| 功能 | 说明 | AI参与方式 |
|------|------|-----------|
| **自动化部署** | 持续集成部署 | AI生成部署脚本 |
| **Release Notes** | 版本发布说明 | AI根据PR/Commit自动生成 |
| **风险预测** | 高风险变更预警 | AI分析代码变动预测风险 |
| **质量门禁** | 代码质量检查 | AI辅助代码审查 |

---

## 7. 质量保障

### 7.1 SDD 质量门禁

| 检查项 | 标准 | 检查方式 |
|--------|------|----------|
| 规格完整性 | 必填字段100%覆盖 | 自动化校验 |
| 接口一致性 | 规格与实现一致 | Contract测试 |
| 设计评审 | 评审通过 | 人工评审 |

### 7.2 TDD 质量门禁

| 检查项 | 标准 | 检查方式 |
|--------|------|----------|
| 测试覆盖率 | ≥80% | 自动化统计 |
| 测试用例评审 | 评审通过 | 人工评审 |
| 回归测试 | 100%通过 | CI自动运行 |

### 7.3 代码质量门禁

| 检查项 | 标准 | 检查方式 |
|--------|------|----------|
| 静态检查 | 0 Error | ESLint/SonarQube |
| 安全扫描 | 0 高危漏洞 | Snyk/AI SAST |
| CR审批 | 至少1人Approve | GitHub PR |

### 7.4 Agent 评测体系

#### 7.4.1 评测集构造

| 类型 | 来源 | 用途 |
|------|------|------|
| **种子集** | 人工标注 | 初始评测基准 |
| **Badcase集** | 用户反馈 | 问题修复验证 |
| **扩展集** | LLM泛化 | 扩大评测覆盖 |
| **对抗集** | 专门设计 | 边界场景测试 |

#### 7.4.2 评测指标

| 类别 | 指标 | 目标 |
|------|------|------|
| **效果指标** | 任务完成率 | >90% |
| **效果指标** | 准确率 | >85% |
| **技术指标** | 响应时间 | <30s |
| **技术指标** | Token消耗 | 合理范围 |
| **用户指标** | 满意度 | >80% |
| **用户指标** | 使用频率 | 持续增长 |

---

## 8. 实施路径

### 8.1 第一阶段：基础构建（1-2个月）

**目标**：建立基础设施和流程框架

| 任务 | 负责人 | 产出 |
|------|--------|------|
| 建立知识库架构 | 架构师 | 三层知识库目录结构 |
| 编写SDD模板 | 架构师 | Speckit模板集 |
| 配置TDD流程 | 开发Leader | TDD工作流文档 |
| 选型AI工具链 | 技术负责人 | 工具选型报告 |
| 制定开发章程 | 技术负责人 | 开发规范文档 |

### 8.2 第二阶段：流程落地（2-3个月）

**目标**：试点验证并建立评测体系

| 任务 | 负责人 | 产出 |
|------|--------|------|
| 试点项目验证 | 项目组 | 验证报告 |
| SDD/TDD流程推广 | 开发Leader | 培训材料 |
| AI工具培训 | AI专家 | 培训课程 |
| 质量门禁建立 | QA | 门禁配置 |
| 评测体系搭建 | AI专家 | 评测平台 |

**试点选择标准**：
- 单职能单仓库
- 日常需求（非紧急）
- 团队积极性高

### 8.3 第三阶段：规模推广（3-6个月）

**目标**：全面推广和工具链整合

| 任务 | 负责人 | 产出 |
|------|--------|------|
| 多职能多仓库需求 | 项目组 | 交付成果 |
| 知识库AI聚合上线 | DevOps | 聚合系统 |
| 团队全员培训 | 技术负责人 | 培训记录 |
| 工具链整合 | DevOps | 集成方案 |
| 最佳实践沉淀 | 架构师 | 最佳实践库 |

### 8.4 第四阶段：持续优化（持续进行）

**目标**：持续改进和能力提升

| 任务 | 负责人 | 产出 |
|------|--------|------|
| 项目级需求支持 | 项目组 | 交付成果 |
| 长期记忆优化 | AI专家 | 记忆系统升级 |
| 数据驱动改进 | 技术负责人 | 改进报告 |
| AI驱动模式探索 | 架构师 | 探索报告 |
| 效能持续提升 | 团队 | 效能报告 |

---

## 9. 度量与优化

### 9.1 SDD/TDD 效能指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 规格到代码转化率 | 规格直接生成代码的比例 | >70% |
| 测试先行遵从率 | 先写测试的需求占比 | >90% |
| 设计复用率 | 复用已有设计的比例 | >50% |
| 缺陷逃逸率 | 未被测试发现的缺陷比例 | <5% |

### 9.2 AI 协作指标

| 指标 | 定义 | 目标 |
|------|------|------|
| AI代码采纳率 | AI生成代码被采纳的比例 | >60% |
| AI辅助时间节省 | 相比传统方式节省的时间 | >30% |
| AI生成准确率 | AI首次生成即正确的比例 | >70% |
| 监督对话轮次 | 完成任务所需对话轮次 | <5轮 |

### 9.3 知识库健康指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 知识覆盖率 | 代码模块被知识库覆盖的比例 | >90% |
| 知识新鲜度 | 知识库最后更新时间 | <30天 |
| 聚合准确率 | AI聚合内容正确的比例 | >85% |
| 开发者满意度 | 对知识库的满意度调研 | >80% |

### 9.4 综合效能指标

| 指标 | 定义 | 目标 |
|------|------|------|
| 开发效能提升率 | 相比传统方式的效率提升 | >30% |
| 代码质量改善率 | 代码质量指标的改善 | >20% |
| Bug率下降率 | Bug数量的下降比例 | >25% |
| 单需求成本 | 每个需求的AI Token成本 | <100元 |

---

## 10. 风险与应对

### 10.1 技术风险

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| AI不确定性 | 生成代码质量不稳定 | 评测体系+人工监督 |
| 代码安全 | 敏感信息泄露 | 代码脱敏处理 |
| 工具依赖 | 单一供应商风险 | 多工具备选方案 |

### 10.2 管理风险

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| 期望过高 | 落地效果不及预期 | 明确AI能力边界 |
| 成本失控 | Token费用超预算 | 成本监控+优化 |
| 质量下降 | 追求速度牺牲质量 | 质量门禁强制执行 |

### 10.3 组织风险

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| 技能转型 | 开发者适应困难 | 系统培训+渐进推广 |
| 文化冲突 | 抵触AI协作模式 | 试点验证+成功案例 |
| 角色变化 | 工作方式不适应 | 明确新角色定位 |

---

## 11. 附录

### 11.1 术语表

| 术语 | 定义 |
|------|------|
| **SDD** | Specification-Driven Development，规范驱动开发 |
| **TDD** | Test-Driven Development，测试驱动开发 |
| **MCP** | Model Context Protocol，模型上下文协议 |
| **RAG** | Retrieval-Augmented Generation，检索增强生成 |
| **ADR** | Architecture Decision Record，架构决策记录 |
| **HITL** | Human-In-The-Loop，人工监督 |

### 11.2 参考资源

- [Speckit 工作流文档](./speckit/)
- [OpenSpec 变更管理](./openspec/)
- [知识库架构设计](./knowledge-design.md)
- [有赞 AI Coding 实践](../docs-example/youzan-ai-coding.md)

### 11.3 版本历史

| 版本 | 日期 | 作者 | 变更说明 |
|------|------|------|----------|
| 1.0 | 2025-12-01 | 架构团队 | 初始版本 |
| 2.0 | 2025-12-01 | 架构团队 | 新增代码设计规范（SOLID原则、设计模式）、编码技巧规范；完善Code Review流程与检查清单 |
| 2.1 | 2025-12-01 | 架构团队 | 整合SpecKit知识库增强：SDD阶段知识库集成、架构合规检查机制、知识库配置 |

---

**文档结束**
