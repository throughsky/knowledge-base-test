# 第2章 流程重塑

## 2.1 SDD 规范驱动开发【核心】

### 2.1.1 设计先行原则

SDD的核心理念是"**设计即约束**"——通过清晰的功能规格文档约束AI的代码生成行为，避免过度实现和功能蔓延。

**功能规格文档结构**：

```markdown
# 功能规格: [功能名称]

## 1. 需求详细说明
- 业务背景
- 用户故事
- 验收标准

## 2. 技术设计文档
- 架构设计
- 数据模型
- 接口定义

## 3. 接口契约
- API规范 (OpenAPI/GraphQL)
- 请求/响应示例
- 错误码定义

## 4. 约束条件
- 技术栈限定
- 代码行数控制
- 排除功能清单
```

### 2.1.2 SDD 工作流程

基于 Speckit 的标准化工作流：

```
┌──────────────────────────────────────────────────────────────┐
│                    SDD 工作流程                               │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐        │
│  │   specify   │ → │    plan     │ → │    tasks    │        │
│  │  自然语言   │   │  实施计划   │   │  可执行任务  │        │
│  │  →功能规格  │   │  →设计文档  │   │  →任务列表   │        │
│  └─────────────┘   └─────────────┘   └─────────────┘        │
│                                              ↓               │
│                                      ┌─────────────┐        │
│                                      │  implement  │        │
│                                      │  任务→代码  │        │
│                                      └─────────────┘        │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

**工作流命令**：

| 命令 | 功能 | 输入 | 输出 |
|------|------|------|------|
| `/speckit.specify` | 创建功能规格 | 自然语言描述 | spec.md |
| `/speckit.plan` | 生成实施计划 | spec.md | plan.md |
| `/speckit.tasks` | 生成任务列表 | plan.md | tasks.md |
| `/speckit.implement` | 执行代码实现 | tasks.md | 代码文件 |
| `/speckit.analyze` | 跨产物分析 | spec/plan/tasks | 一致性报告 |
| `/speckit.clarify` | 需求澄清 | spec.md | 澄清问题 |
| `/speckit.archive` | 知识沉淀归档 | 已实现功能 | registry.json, ADR |

### 2.1.3 知识库集成增强

**各阶段知识库读取**：

| 阶段 | 知识库层级 | 读取内容 | 用途 |
|------|------------|----------|------|
| **specify** | L1 项目级 | glossary.md, domain-model.md | 术语规范、实体识别 |
| **specify** | L2 仓库级 | context.md, overview.md | 模块边界、避免重复 |
| **plan** | L0 企业级 | architecture-principles.md | 架构合规检查 |
| **plan** | L1 项目级 | tech-stack.md, ADR-*.md | 技术选型、ADR一致性 |
| **plan** | L2 仓库级 | module_tree.json, {module}.md | 路径规范、组件复用 |
| **tasks** | L2 仓库级 | module_tree.json | 文件路径验证 |
| **implement** | L2 仓库级 | {module}.md | 代码模式参考 |

### 2.1.4 架构合规检查

在 `/speckit.plan` 的 Phase 0 和 Phase 1 之间强制执行架构合规检查：

**九大原则检查矩阵**：

| 原则 | 检查项 | 严重级别 |
|------|--------|----------|
| I. TDD | 测试策略、覆盖率目标 | CRITICAL |
| III. 微服务架构 | 分层结构、技术栈合规 | CRITICAL |
| IV. 安全优先 | 输入校验、审计日志 | CRITICAL |
| V. RESTful | API设计规范 | HIGH |
| VI. 生产就绪 | 错误处理、事务管理 | HIGH |
| VIII. 简洁性 | YAGNI、依赖管理 | MEDIUM |
| IX. 事件驱动 | 事件监听、幂等性 | HIGH |

**合规检查输出**：

```markdown
## Architecture Compliance Check

| 原则 | 适用性 | 检查结果 | 说明 |
|------|--------|----------|------|
| I. TDD | ✓ | ✅ | 已规划单元测试和集成测试 |
| III. 微服务 | ✓ | ⚠️ | 技术栈合规，分层需调整 |
| IV. 安全 | ✓ | ✅ | 已规划输入校验和审计日志 |

**处理规则**: ✅全部合规→继续 | ⚠️需调整→修改后继续 | ❌违规→阻止流程
```

### 2.1.5 AI 协同 SDD 实践

**Prompt 模板化**：

```markdown
## 任务
根据以下规格文档实现 [功能名称]

## 约束条件
- 技术栈: [具体技术栈]
- 代码行数: 不超过 [N] 行
- 排除功能: [明确排除列表]

## 输入规格
[粘贴 spec.md 相关内容]

## 输出要求
- 遵循项目编码规范
- 包含单元测试
- 提供使用示例
```

**防止 AI 过度联想**：

| 策略 | 说明 | 示例 |
|------|------|------|
| **负向提示** | 明确列出不需要的功能 | "不需要：密码重置、邮箱验证、OAuth" |
| **领域边界** | 定义功能边界 | "仅限用户基础信息CRUD，不涉及权限" |
| **单一事实源** | 限制输入输出 | "输入：用户名+密码，输出：JWT token" |

**渐进式迭代**：

```
第1轮: 核心数据模型
    ↓
第2轮: 基础CRUD接口
    ↓
第3轮: 业务逻辑层
    ↓
第4轮: 验证和错误处理
    ↓
第5轮: 测试用例补充
```

### 2.1.6 知识生命周期管理【增强】

SpecKit 生成的文档（spec.md, plan.md, tasks.md）存在"一次性使用"的问题，导致历史决策丢失、跨需求信息孤岛。本节定义知识沉淀与复用机制。

#### 2.1.6.1 问题陈述

**当前知识断层**：

```
┌─────────────────────────────────────────────────────────────────┐
│                    当前文档生命周期                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  需求A                                                          │
│    ↓                                                            │
│  /speckit.specify → spec.md ─┐                                  │
│    ↓                         │                                  │
│  /speckit.plan → plan.md ────┼──→ features/feature-a/ (归档)    │
│    ↓                         │                                  │
│  /speckit.tasks → tasks.md ──┘                                  │
│    ↓                                                            │
│  /speckit.implement → 代码实现                                   │
│    ↓                                                            │
│  ══════════════════════════════════════════════════════════════ │
│                     知识断层 (Knowledge Gap)                     │
│  ══════════════════════════════════════════════════════════════ │
│    ↓                                                            │
│  需求B (新需求)                                                  │
│    ↓                                                            │
│  /speckit.specify → 无法访问需求A的决策历史                       │
│    ↓                                                            │
│  可能产生：重复设计 | 决策冲突 | 架构不一致                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心问题**：

| 问题 | 影响 | 严重程度 |
|------|------|----------|
| 文档一次性使用 | 历史决策丢失，无法复用 | 🔴 高 |
| 无跨需求关联 | 相关需求间信息孤岛 | 🔴 高 |
| 知识未沉淀 | 架构决策散落各处 | 🟡 中 |
| 缺乏版本演进 | 设计演变历史不可追溯 | 🟡 中 |

#### 2.1.6.2 Feature Registry（特性注册表）

**数据结构**：

```json
// features/registry.json
{
  "version": "1.0",
  "last_updated": "2025-01-15T10:30:00Z",
  "features": [
    {
      "id": "user-authentication",
      "name": "用户认证系统",
      "status": "implemented",
      "created_at": "2025-01-10",
      "completed_at": "2025-01-15",
      "artifacts": {
        "spec": "features/user-authentication/spec.md",
        "plan": "features/user-authentication/plan.md",
        "tasks": "features/user-authentication/tasks.md"
      },
      "summary": {
        "business_goal": "实现安全的用户登录和会话管理",
        "technical_approach": "JWT + OAuth2.0",
        "key_decisions": [
          "使用 JWT 而非 Session 存储",
          "Token 有效期 24 小时",
          "支持 OAuth2.0 第三方登录"
        ]
      },
      "impact": {
        "modules_created": ["auth-service"],
        "modules_modified": ["user-gateway", "common-utils"],
        "apis_added": ["/api/v1/auth/login", "/api/v1/auth/refresh"],
        "domain_entities": ["User", "Session", "Token"]
      },
      "tags": ["authentication", "security", "user-management"],
      "related_features": ["user-registration", "role-based-access"],
      "adr_refs": ["ADR-001-jwt-token-strategy"]
    }
  ],
  "index": {
    "by_module": {
      "auth-service": ["user-authentication", "role-based-access"]
    },
    "by_tag": {
      "security": ["user-authentication", "role-based-access"]
    },
    "by_domain": {
      "User": ["user-authentication", "user-registration"]
    }
  }
}
```

**查询接口**：

| 查询方式 | 输入 | 输出 |
|----------|------|------|
| `find_by_module` | 模块名 | 相关特性列表及摘要 |
| `find_by_domain` | 实体名 | 涉及该实体的特性列表 |
| `find_related` | 特性ID | 关联特性及关联原因 |
| `find_conflicts` | 新特性描述 | 潜在冲突的历史决策 |
| `get_decisions_for_module` | 模块名 | 影响该模块的所有 ADR |

#### 2.1.6.3 知识沉淀命令：/speckit.archive

**触发时机**：`/speckit.implement` 所有任务完成后自动执行

**三阶段流程**：

```
┌─────────────────────────────────────────────────────────────────┐
│                  /speckit.archive 执行流程                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Phase 1: 知识提取                                               │
│  ─────────────────                                              │
│  • 解析 spec.md → business_goal, acceptance_criteria            │
│  • 解析 plan.md → technical_approach, architecture_decisions    │
│  • 解析代码变更 → modules_affected, apis_added, domain_entities │
│                                                                 │
│  Phase 2: 知识沉淀                                               │
│  ─────────────────                                              │
│  • 更新 Feature Registry (features/registry.json)              │
│  • 提取架构决策 → 生成 ADR (如有重要决策)                         │
│  • 更新领域模型 (domain-model.md)                                │
│  • 触发 CodeWiki 更新                                            │
│                                                                 │
│  Phase 3: 关联建立                                               │
│  ─────────────────                                              │
│  • 基于模块、标签、领域实体识别相关特性                           │
│  • 更新 Registry 索引 (by_module, by_tag, by_domain)            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.2 TDD 测试驱动开发【核心】

### 2.2.1 TDD 三定律

1. **先写失败测试**：在编写任何生产代码之前，先编写一个失败的单元测试
2. **仅写足够代码**：只编写刚好能让测试通过的生产代码
3. **重构保持测试**：重构代码时确保所有测试仍然通过

### 2.2.2 红灯-绿灯-重构循环

```
┌─────────────────────────────────────────────────────┐
│              TDD 循环                                │
├─────────────────────────────────────────────────────┤
│                                                     │
│      ┌─────────┐                                    │
│      │  红灯   │ ← 编写失败测试                      │
│      │  RED    │                                    │
│      └────┬────┘                                    │
│           │                                         │
│           ▼                                         │
│      ┌─────────┐                                    │
│      │  绿灯   │ ← 最小代码通过测试                  │
│      │  GREEN  │                                    │
│      └────┬────┘                                    │
│           │                                         │
│           ▼                                         │
│      ┌─────────┐                                    │
│      │  重构   │ ← 优化设计保持绿灯                  │
│      │ REFACTOR│                                    │
│      └────┬────┘                                    │
│           │                                         │
│           └─────────→ 回到红灯                       │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 2.2.3 AI 优先 TDD 流程

将 AI 深度集成到 TDD 流程中：

```
┌─────────────────────────────────────────────────────────────┐
│                AI 优先 TDD 流程                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Step 1: 人工编写测试签名和意图                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ describe('用户注册', () => {                         │   │
│  │   it('应该成功注册新用户', () => {                    │   │
│  │     // 意图: 验证邮箱+密码注册流程                    │   │
│  │   });                                                │   │
│  │ });                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  Step 2: AI 生成完整测试用例                                │
│                          ↓                                  │
│  Step 3: AI 编写通过测试的实现代码                          │
│                          ↓                                  │
│  Step 4: 人工审查和验证                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2.4 测试金字塔

```
                    ┌─────────┐
                    │  E2E    │  10%
                    │  测试   │
                ┌───┴─────────┴───┐
                │   集成测试       │  30%
            ┌───┴─────────────────┴───┐
            │       单元测试           │  60%
            └─────────────────────────┘
```

**测试覆盖率要求**：≥80%

### 2.2.5 测试阶段 D-R-O 职责分工

| 层级 | 内容 |
|------|------|
| **委派** | 基于功能规范生成测试用例、识别边缘情况和故障模式、第一轮测试代码生成 |
| **审查** | 防止 AI 走捷径或实施桩测试（stubbed tests）、验证断言有效性、确保测试可由智能体运行 |
| **掌控** | 测试覆盖率与功能规范对齐、测试策略制定、边缘情况的创造性映射、测试意图的最终确认 |

**AI 测试生成最佳实践**：

| 实践 | 说明 |
|------|------|
| **分离生成** | 在独立会话中生成测试，避免测试与实现循环依赖 |
| **先验证失败** | 确保生成的测试在实现前失败（红灯阶段） |
| **边缘情况发现** | 提示 AI 识别开发者可能忽略的边缘情况 |
| **覆盖率工具集成** | 在 AGENTS.md 中配置覆盖率工具调用方式 |

---

## 2.3 AI 协同开发流程

### 2.3.1 需求阶段

| 活动 | 负责人 | AI参与方式 | 产出 |
|------|--------|------------|------|
| 需求分析 | 产品经理 | LLM分析原始需求 | 用户故事草稿 |
| 任务拆解 | 技术负责人 | AI辅助拆解 | 任务列表 |
| 技术方案 | 架构师 | Vibe-Driven Development | 技术规格 |

**D-R-O 职责分工**：

| 层级 | 内容 |
|------|------|
| **委派** | AI 进行可行性分析第一轮、读取规范映射代码库、识别依赖和歧义、生成工时估算建议 |
| **审查** | 验证估算准确性、评估分析完整性、确认技术约束反映真实情况 |
| **掌控** | 优先级决策、长期方向规划、排序权衡、资源分配 |

**Vibe-Driven Development**：

```
高阶概念 (Vibe)
    ↓ AI对话迭代
技术规格 (Spec)
    ↓ AI对话迭代
实现路径 (Path)
```

### 2.3.2 开发阶段

**人机结对编程规范**：

| 角色 | 职责 |
|------|------|
| **AI** | 样板代码生成、API调用实现、单元测试生成、文档生成 |
| **人** | 业务逻辑设计、架构决策、代码审查、最终验收 |

**D-R-O 职责分工**：

| 层级 | 内容 |
|------|------|
| **委派** | 功能实现初稿、CRUD逻辑、脚手架搭建、重构、样板代码生成、测试编写 |
| **审查** | 评估设计选择、性能影响、安全风险、迁移风险、领域对齐，纠正 AI 遗漏的细微问题 |
| **掌控** | 新抽象设计、跨切面架构变更、模糊产品需求澄清、长期可维护性权衡 |

**从规格生成代码**：

```
OpenAPI/Swagger  →  API客户端 + 服务器路由
GraphQL Schema   →  类型定义 + Resolver骨架
数据库DDL       →  ORM模型 + Repository层
```

### 2.3.3 Code Review 阶段

**Code Review 的核心目的**：

1. **让代码更加统一、规范、易维护**：通过统一的代码风格和规范，降低维护成本
2. **方便开发人员互相学习经验，达到知识共享**：促进团队整体技术水平提升
3. **帮助开发人员跳出固定思维，得出最优解决思路**：多人Review从不同角度审视代码
4. **从可运行到可重用**：使代码不仅能完成功能，还具备良好的可重用性和扩展性

**双层 CR 机制**：

```
┌─────────────────────────────────────────────────────────────┐
│                    双层 CR 机制                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  第一层: AI 自动化 Review                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 代码风格检查                                       │   │
│  │ • 潜在 Bug 检测                                      │   │
│  │ • 最佳实践建议                                       │   │
│  │ • 安全漏洞扫描                                       │   │
│  │ • 性能问题识别                                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  第二层: 人类 Reviewer                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 架构一致性                                         │   │
│  │ • 业务逻辑正确性                                     │   │
│  │ • 系统可扩展性                                       │   │
│  │ • 设计模式合理性                                     │   │
│  │ • 领域建模正确性                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Code Review 完整流程**：

```
1. 开发者提交代码
       ↓
2. 自我 Review（开发者自查基本规范），与SDD流程绑定
       ↓
3. AI 自动化 Review（CI触发）
       ↓
4. 同行 Review（团队成员审查）
       ↓
5. 讨论与修改（针对意见修改）
       ↓
6. 二次 Review（重大问题修改后）
       ↓
7. 合并代码
```

**Code Review 检查清单**：

| 检查维度 | 检查项 |
|----------|--------|
| **功能性** | 代码是否实现需求功能、边界条件处理、逻辑错误检查 |
| **设计性** | 是否符合SOLID原则、职责划分合理性、避免过度设计 |
| **代码质量** | 可读性、命名清晰度、注释充分性 |
| **性能安全** | 性能瓶颈、资源释放、安全漏洞 |

**D-R-O 职责分工**：

| 层级 | 内容 |
|------|------|
| **委派** | 初始代码审查（可多次）、代码风格检查、潜在 Bug 检测、安全漏洞扫描、最佳实践建议 |
| **审查** | 架构对齐验证、可组合模式评估、惯例使用正确性、功能符合需求确认 |
| **掌控** | 最终合并决策、部署到生产环境的代码质量负责、运行可靠性和需求满足的最终确认 |

---

## 相关章节

- [上一章：概述](./01-introduction.md)
- [下一章：代码设计规范](./03-code-design-standards.md)
- [返回概要](./00-overview.md)
