# 第3章 代码设计规范

## 3.1 三阶段编程方法论

优秀的代码设计需要经历三个阶段：**分析 → 设计 → 打磨**

```
┌─────────────────────────────────────────────────────────────┐
│                    三阶段编程                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐       │
│  │   分析阶段   │ → │   设计阶段   │ → │   打磨阶段   │       │
│  │             │   │             │   │             │       │
│  │ • 分析需求   │   │ • 分配职责   │   │ • 选择模式   │       │
│  │ • 识别实体   │   │ • GRASP原则  │   │ • 提高可读   │       │
│  │ • 找核心概念 │   │ • 确保清晰   │   │ • 优化维护   │       │
│  └─────────────┘   └─────────────┘   └─────────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**分析阶段**：

- 不要急于实现功能，避免陷入事务脚本模式（面向过程）
- 分析需求的本质目的
- 识别完成功能需要的核心实体
- 核心是"**找实体**"

**设计阶段**：

- 将职责合理分配到各个实体上
- 运用 GRASP 原则指导设计
- 确保职责分配的合理性和清晰性

**打磨阶段**：

- 选择合适的设计模式实现
- 提高代码的可读性和可维护性
- 使用模板模式处理通用业务流程

---

## 3.2 SOLID 设计原则

SOLID 是面向对象设计的五大基本原则，是编写高质量代码的基石：

### 3.2.1 单一职责原则 (SRP)

**定义**：一个类只负责完成一个职责或功能，不应存在多于一种导致类变更的原因。

**优势**：

- 提高类的内聚性
- 降低代码耦合性
- 使代码更易于理解和维护

**注意**：不要过度拆分，否则会降低内聚性，影响可维护性

### 3.2.2 开放-关闭原则 (OCP)

**定义**：对扩展开放，对修改关闭。添加新功能应通过扩展代码而非修改已有代码。

**实现方式**：

- 使用多态
- 依赖注入
- 基于接口而非实现编程
- 应用设计模式（装饰、策略、模板、职责链、状态等）

### 3.2.3 里氏替换原则 (LSP)

**定义**：子类对象能够替换程序中父类对象出现的任何地方，并保证原有程序逻辑行为不变。

**核心要求**：

- 子类可以扩展父类功能
- 子类不能改变父类原有功能
- 父类已实现的方法是规范和契约

### 3.2.4 接口隔离原则 (ISP)

**定义**：调用方不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

**判断标准**：如果调用者只使用部分接口或接口的部分功能，说明接口设计不够职责单一。

### 3.2.5 依赖反转原则 (DIP)

**定义**：

- 高层模块不应该依赖低层模块，二者都应该依赖其抽象
- 抽象不应该依赖细节，细节应该依赖抽象

**实践**：面向接口编程，而不是面向实现编程

### 3.2.6 其他重要原则

| 原则 | 说明 |
|------|------|
| **迪米特法则** | 一个对象应该对其他对象保持最少的了解，降低耦合度 |
| **合成复用原则** | 尽量使用组合/聚合方式，而不是使用继承 |

---

## 3.3 设计模式应用指南

设计模式是经过验证的问题解决方案，核心思想是"**找到变化，封装变化**"。

### 创建型模式

| 模式 | 说明 | 适用场景 |
|------|------|----------|
| **单例** | 一个类只允许创建一个实例 | 无状态/全局唯一/控制资源访问 |
| **工厂** | 创建相关对象，使用者不关心具体实现类 | 分离对象创建和使用 |
| **建造者** | 创建复杂对象，通过设置可选参数定制化 | 构造参数较多且多数可选 |
| **原型** | 通过复制已有对象创建新对象 | 对象创建成本大且差别不大 |

### 结构型模式

| 模式 | 说明 | 适用场景 |
|------|------|----------|
| **代理** | 不改变原始类情况下，通过代理类附加功能 | 监控、缓存、限流、事务、RPC |
| **装饰者** | 不改变原始类情况下，通过组合动态扩展功能 | 动态扩展类的功能 |
| **适配器** | 不改变原始类情况下，使其适配新接口 | 复用现有类，但接口不适配 |
| **桥接** | 多个独立变化维度时，通过组合独立扩展 | 存在多维度继承体系 |
| **门面** | 为子系统定义更高层接口，使其更易使用 | 解决接口复用性与易用性矛盾 |
| **组合** | 将对象组合成树形结构，统一处理 | 满足部分-整体树形结构 |
| **享元** | 运用共享技术支持大量细粒度对象 | 大量对象且字段取值范围固定 |

### 行为型模式

| 模式 | 说明 | 适用场景 |
|------|------|----------|
| **观察者** | 主题对象状态变化时通知所有观察者 | 解耦事件创建者与接收者 |
| **模板** | 定义算法骨架，延迟某些步骤到子类 | 解决复用与扩展问题 |
| **策略** | 封装一组算法，使其可互相替换 | 消除if-else，解耦策略定义/创建/使用 |
| **状态** | 对象内部状态改变时改变其行为 | 分离对象状态与行为 |
| **职责链** | 对象连成链，请求沿链传递直到被处理 | 解耦请求发送者与接收者 |
| **迭代器** | 顺序访问集合元素，不暴露内部表示 | 解耦集合内部表示与遍历访问 |
| **命令** | 将请求封装成命令对象，控制执行过程 | 异步、延迟、排队、撤销、存储命令 |

---

## 相关章节

- [上一章：流程重塑](./02-process-redesign.md)
- [下一章：编码技巧规范](./04-coding-practices.md)
- [返回概要](./00-overview.md)
