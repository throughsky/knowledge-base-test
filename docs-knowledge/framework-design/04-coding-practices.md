# 第4章 编码技巧规范

## 4.1 方法级优化技巧

### 4.1.1 提炼方法与意图导向编程

**适用场景**：

- 多个方法代码重复
- 方法中代码过长（一般不超过80行）
- 方法中语句不在同一抽象层级

**意图导向编程原则**：

- 将处理流程和具体实现分离
- 把问题分解为一系列功能性步骤
- 假定功能步骤已实现，先组织整体流程
- 最后再实现各个具体方法

```
示例 - 交易处理流程：
1. 解析交易字符串
2. 转换为词汇元素数组
3. 标准化每个词汇
4. 根据规模选择提交算法
5. 返回提交结果
```

### 4.1.2 其他方法级技巧

| 技巧 | 说明 |
|------|------|
| **以函数对象取代函数** | 将大型函数放进单独对象中，局部变量变成对象字段 |
| **引入参数对象** | 方法参数较多时，将参数封装为参数对象 |
| **移除对参数的赋值** | 有返回值的方法不应有副作用，避免修改参数值 |
| **引入解释性变量** | 将复杂表达式结果放入临时变量，用变量名解释用途 |
| **try-catch内部代码抽成方法** | 保持核心逻辑清晰 |

---

## 4.2 条件判断优化

### 4.2.1 使用卫语句替代嵌套条件

**原则**：把复杂的条件表达式拆分成多个条件表达式，减少嵌套。

```
// 反例：多层嵌套
if (condition1) {
    if (condition2) {
        if (condition3) {
            // 核心逻辑
        }
    }
}

// 正例：卫语句
if (!condition1) return;
if (!condition2) return;
if (!condition3) return;
// 核心逻辑
```

**优势**：降低复杂度、提高可读性、核心逻辑更清晰

### 4.2.2 使用多态替代条件判断

**适用场景**：当存在根据对象类型选择不同行为的条件表达式时

**实现方式**：

- 将每个分支放进子类内的覆写方法
- 将原始函数声明为抽象函数
- 利用多态机制自动选择正确的实现

---

## 4.3 异常处理规范

### 4.3.1 使用异常替代返回错误码

**原则**：非正常业务状态使用抛出异常方式，而不是返回错误码。

**实施要点**：

- 通过最上层统一处理异常，转换成标准返回码
- 不要使用异常处理正常的业务流程控制
- 尽量使用标准异常
- 避免在 finally 语句块中抛出异常
- finally 块中只做关闭资源类操作

**典型模式**：

```
1. 业务逻辑层抛出业务异常
       ↓
2. 服务层简单调用，不处理异常
       ↓
3. 控制层（Controller/Filter）统一拦截处理异常
```

### 4.3.2 引入断言

**使用原则**：

- 只用于检查"一定必须为真"的条件
- 不用于检查"应该为真"的条件
- 如果断言条件不满足，代码仍能正常运行，则去掉断言

---

## 4.4 空值处理

### 4.4.1 引入 Null 对象或特殊对象

**问题**：频繁的判空操作影响代码美观和可读性，增加 Bug 几率

**解决方案**：

- 创建一个特殊的空对象类
- 空对象提供默认的安全行为
- 使用 Optional 优雅处理

**空指针产生原因**：

- 数据库查询结果为 null
- 集合/数组访问越界
- 对象方法调用时对象为 null

---

## 4.5 类设计优化

### 4.5.1 提炼类

**适用场景**：

- 类包含大量数据和函数
- 逻辑复杂不易理解
- 职责不断增加

**判断依据**：

- 某些数据和方法总是一起出现
- 某些数据经常同时变化
- 子类化只影响类的部分特性

**原则**：高内聚低耦合

### 4.5.2 组合优先于继承

**继承的局限性**：

- 打破封装性
- 子类依赖父类实现细节
- 父类变化可能破坏子类

**组合的优势**：

- 通过私有域引用现有类实例
- 不依赖现有类实现细节
- 更加稳固和灵活

**使用场景判断**：

- 仅当存在真正的"is-a"关系时使用继承
- 包内部使用继承是安全的
- 其他情况优先考虑组合

### 4.5.3 接口优于抽象类

**接口优势**：

- 现有类可以轻松实现新接口
- 是定义混合类型的理想选择
- 允许构造非层次结构的类型框架

**最佳实践**：接口 + 骨架实现类（模板方法设计模式）

---

## 4.6 泛型使用规范

| 规范 | 说明 |
|------|------|
| **优先考虑泛型** | 编译时类型安全、避免类型转换 |
| **不要使用原生态类型** | 使用原生态类型会失去泛型优势 |
| **消除非受检警告** | 每条警告都表示可能的 ClassCastException |
| **PECS 原则** | Producer-Extends, Consumer-Super |

---

## 4.7 代码质量提升技巧

| 技巧 | 说明 |
|------|------|
| **优先使用模板/工具类** | 减少重复代码，专注业务逻辑 |
| **分离对象的创建与使用** | 工厂模式、构建器模式、依赖注入 |
| **可访问性最小化** | 尽可能使每个类和成员不被外界访问 |
| **可变性最小化** | 不可变类简单、线程安全、可自由共享 |
| **静态成员类优于非静态成员类** | 非静态成员类会隐式持有外部类引用 |

---

## 4.8 参数校验与返回规范

### 4.8.1 优雅地参数校验

**格式校验**：

- 使用 hibernate-validator 框架
- 在实体类上使用 @NotBlank、@NotNull 等注解
- Controller 方法上使用 @Valid 注解

**业务校验**：

- 自定义校验注解
- 实现 ConstraintValidator 接口

### 4.8.2 统一返回值

**原则**：

- 所有接口使用统一的返回值结构
- 包含状态码、消息、数据等标准字段
- 便于接口调用方统一解析

### 4.8.3 统一异常处理

**实现方式**：

- 使用 @ControllerAdvice
- 使用 @ExceptionHandler
- 统一转换异常为标准返回格式

---

## 4.9 并发编程规范

| 规范 | 说明 |
|------|------|
| **涉及线程间可见性加 volatile** | 保证线程间的可见性 |
| **减小锁使用范围** | 只给需要加锁的代码加锁，在 finally 中释放锁 |
| **分布式锁规范** | 必须设置过期时间和获取锁的超时时间 |

---

## 4.10 性能优化技巧

| 技巧 | 说明 |
|------|------|
| **集合指定初始化大小** | 避免扩容消耗性能 |
| **不要使用 BeanUtils 拷贝属性** | 基于反射性能较差，使用 MapStruct |
| **使用 StringBuilder 拼接字符串** | 减少对象创建 |
| **不循环调用数据库** | 批量查询 + 转换为 Map + 内存匹配 |
| **用业务代码代替多表 join** | 在应用层进行数据关联 |
| **远程接口调用设置超时时间** | 防止线程"卡死" |

---

## 4.11 其他最佳实践

| 实践 | 说明 |
|------|------|
| **尽量使用工具类** | CollectionUtils、StringUtils、Hutool 等 |
| **面向接口编程** | 引用父类或抽象，而非实现 |
| **魔法值用常量表示** | 提高可读性，便于维护 |
| **有类型区分时定义好枚举** | 避免魔法数字，提供类型安全 |
| **写好代码注释** | 解释为什么这样做，而不是怎么做 |

---

## 相关章节

- [上一章：代码设计规范](./03-code-design-standards.md)
- [下一章：多级知识空间](./05-knowledge-spaces.md)
- [返回概要](./00-overview.md)
