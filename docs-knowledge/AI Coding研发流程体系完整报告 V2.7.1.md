
# AI Coding研发流程体系完整报告 V2.7.1

## 执行摘要

本文档定义了以 **SDD（规范驱动开发）** 和 **TDD（测试驱动开发）** 为核心驱动力的 AI Coding 研发流程体系，结合多级知识空间架构和统一工具链基础设施，实现从"人工编码"到"AI协同编码"的研发模式转型。

### 关键成功要素

**技术层面**：

- 规范与测试的双重驱动确保质量，约束rule先行，见效最快。
- 三层知识架构支撑AI理解，仓库级知识库尽量AI自动化，降低维护负担
- 统一工具链降低认知负担
- 数据驱动的持续优化，知识库生命周期管理

**组织层面**：

- 循序渐进的实施路径
- 质量第一的文化建设
- 团队对AI协作的认同

**核心策略**：

- AI不是万能的，我们能做的先做，例如强化架构要求、强化质量和测试要求、强化各级别的约束要求
- 保持跟随，例如社区的codebase、其他领域的subagent模式等一直在演进中


### 全景思维导图

展示整个体系的核心构成，包括核心理念（SDD、TDD、D-R-O）、三层知识空间、统一工具链、质量保障体系和核心价值指标。

![AI Coding研发流程体系全景思维导图](https://cdn.gooo.ai/gen-images/a76210201bea534c12b06eeb80f946c0a0601308cdf2c7a831f2a20f446e9fda.svg)

### 研发流程架构图--需要增加知识库增强环节

完整呈现从需求到知识沉淀的端到端流程，包括需求阶段、设计阶段（含九大原则合规检查）、开发阶段（TDD红绿重构循环）、Code Review双层审查机制，以及知识沉淀归档流程。

![AI Coding研发流程架构图](https://cdn.gooo.ai/gen-images/51740df8f5c2510ff0e71b93d34d372e87be4e55a0a08888676987e7ac37c255.svg)

---

## 第一章：概述与核心理念

### 1.1 设计目标

AI Coding 研发流程体系旨在通过规范化、自动化和智能化手段，提升软件研发效能，确保代码质量，实现人机协同的高效开发模式。

### 1.2 核心理念架构

```plaintext
┌─────────────────────────────────────────────────────────────────┐
│                    AI Coding 研发流程体系                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│   │  SDD驱动    │ ←→ │  TDD驱动    │ ←→ │  AI协同     │        │
│   │  规范先行   │    │  测试先行   │    │  人机结对   │        │
│   └─────────────┘    └─────────────┘    └─────────────┘        │
│          ↑                  ↑                  ↑                │
│          └──────────────────┼──────────────────┘                │
│                             │                                   │
│   ┌─────────────────────────┴─────────────────────────┐        │
│   │              多级知识空间 + 统一工具链              │        │
│   │         L0企业级 → L1项目级 → L2仓库级             │        │
│   └───────────────────────────────────────────────────┘        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 核心原则

| 原则               | 说明                                           |
| ------------------ | ---------------------------------------------- |
| **规范驱动** | 先有设计规范，后有代码实现，AI直接消费设计规范 |
| **测试先行** | 先写测试定义行为，再由AI生成实现代码           |
| **知识分层** | 企业→项目→仓库三层知识架构，自底向上聚合     |
| **工具统一** | 统一的AI工具链和开发环境，降低认知负担         |
| **持续改进** | 数据驱动的效能度量和流程优化                   |

### 1.4 委派-审查-掌控框架（D-R-O）

AI 协同开发的核心是明确人机职责边界。在 SDLC 每个阶段，采用 **D-R-O 框架**定义 AI 与人类的分工：

```plaintext
┌─────────────────────────────────────────────────────────────────┐
│                委派-审查-掌控 (D-R-O) 框架                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐                                            │
│  │   委派 Delegate │  → AI 可独立完成的任务                      │
│  │   (交给 AI)     │    样板代码、初稿生成、模式应用              │
│  └────────┬────────┘                                            │
│           │                                                     │
│           ▼                                                     │
│  ┌─────────────────┐                                            │
│  │   审查 Review   │  → 人类验证 AI 产出                         │
│  │   (人类把关)    │    准确性、完整性、合规性检查                │
│  └────────┬────────┘                                            │
│           │                                                     │
│           ▼                                                     │
│  ┌─────────────────┐                                            │
│  │   掌控 Own      │  → 人类必须负责的决策                       │
│  │   (人类主导)    │    战略方向、架构决策、最终审批              │
│  └─────────────────┘                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**各阶段 D-R-O 职责总览**：

| SDLC 阶段      | 委派 (AI)                              | 审查 (人类)                | 掌控 (人类)                      |
| -------------- | -------------------------------------- | -------------------------- | -------------------------------- |
| **规划** | 可行性分析初稿、依赖识别、工时估算建议 | 验证估算准确性、评估完整性 | 优先级决策、长期方向、资源分配   |
| **设计** | 原型搭建、样板代码、设计稿转代码       | 组件规范合规、质量标准验证 | 设计系统、UX模式、架构决策       |
| **构建** | 功能实现初稿、CRUD逻辑、测试生成       | 设计选择、性能、安全评估   | 新抽象、跨切面架构、可维护性权衡 |
| **测试** | 测试用例生成、边缘情况识别             | 防止桩测试、验证断言有效性 | 测试策略、覆盖率与业务对齐       |
| **审查** | 代码风格检查、潜在Bug检测、安全扫描    | 架构一致性、业务逻辑正确性 | 最终合并决策、部署审批           |
| **文档** | 模块摘要、API描述、Release Notes初稿   | 准确性验证、关键变更确认   | 文档策略、面向客户/安全关键文档  |
| **运维** | 日志分析、异常识别、修复建议           | 根因确认、修复方案评估     | 敏感操作签署、事故最终判断       |

**核心原则**：

- **AI 是第一轮实施者**，人类是审阅者、编辑者和方向来源
- **机械性工作委派**，创造性决策掌控
- **可逆操作委派**，不可逆操作掌控

---

## 第二章：流程重塑

### 2.1 SDD 规范驱动开发【核心】

#### 2.1.1 设计先行原则

SDD的核心理念是"**设计即约束**"——通过清晰的功能规格文档约束AI的代码生成行为，避免过度实现和功能蔓延。

**功能规格文档结构**：

```markdown
# 功能规格: [功能名称]

## 1. 需求详细说明
- 业务背景
- 用户故事
- 验收标准

## 2. 技术设计文档
- 架构设计
- 数据模型
- 接口定义

## 3. 接口契约
- API规范 (OpenAPI/GraphQL)
- 请求/响应示例
- 错误码定义

## 4. 约束条件
- 技术栈限定
- 代码行数控制
- 排除功能清单
```

#### 2.1.2 SDD 工作流程

基于 Speckit 的标准化工作流：

```plaintext
┌──────────────────────────────────────────────────────────────┐
│                    SDD 工作流程                               │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐        │
│  │   specify   │ → │    plan     │ → │    tasks    │        │
│  │  自然语言   │   │  实施计划   │   │  可执行任务  │        │
│  │  →功能规格  │   │  →设计文档  │   │  →任务列表   │        │
│  └─────────────┘   └─────────────┘   └─────────────┘        │
│                                              ↓               │
│                                      ┌─────────────┐        │
│                                      │  implement  │        │
│                                      │  任务→代码  │        │
│                                      └─────────────┘        │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

**工作流命令**：

| 命令                   | 功能         | 输入                     | 输出                     |
| ---------------------- | ------------ | ------------------------ | ------------------------ |
| `/speckit.specify`   | 创建功能规格 | 自然语言描述             | [spec.md](http://spec.md)   |
| `/speckit.plan`      | 生成实施计划 | [spec.md](http://spec.md)   | [plan.md](http://plan.md)   |
| `/speckit.tasks`     | 生成任务列表 | [plan.md](http://plan.md)   | [tasks.md](http://tasks.md) |
| `/speckit.implement` | 执行代码实现 | [tasks.md](http://tasks.md) | 代码文件                 |
| `/speckit.analyze`   | 跨产物分析   | spec/plan/tasks          | 一致性报告               |
| `/speckit.clarify`   | 需求澄清     | [spec.md](http://spec.md)   | 澄清问题                 |
| `/speckit.archive`   | 知识沉淀归档 | 已实现功能               | registry.json, ADR       |

#### 2.1.3 知识库集成增强

**各阶段知识库读取**：

| 阶段                | 知识库层级 | 读取内容                                                               | 用途                |
| ------------------- | ---------- | ---------------------------------------------------------------------- | ------------------- |
| **specify**   | L1 项目级  | [glossary.md](http://glossary.md), [domain-model.md](http://domain-model.md) | 术语规范、实体识别  |
| **specify**   | L2 仓库级  | [context.md](http://context.md), [overview.md](http://overview.md)           | 模块边界、避免重复  |
| **plan**      | L0 企业级  | [architecture-principles.md](http://architecture-principles.md)           | 架构合规检查        |
| **plan**      | L1 项目级  | [tech-stack.md](http://tech-stack.md), ADR-*.md                           | 技术选型、ADR一致性 |
| **plan**      | L2 仓库级  | module_tree.json, {module}.md                                          | 路径规范、组件复用  |
| **tasks**     | L2 仓库级  | module_tree.json                                                       | 文件路径验证        |
| **implement** | L2 仓库级  | {module}.md                                                            | 代码模式参考        |

#### 2.1.4 架构合规检查

在 `/speckit.plan` 的 Phase 0 和 Phase 1 之间强制执行架构合规检查：

**九大原则检查矩阵**：

| 原则            | 检查项               | 严重级别 |
| --------------- | -------------------- | -------- |
| I. TDD          | 测试策略、覆盖率目标 | CRITICAL |
| III. 微服务架构 | 分层结构、技术栈合规 | CRITICAL |
| IV. 安全优先    | 输入校验、审计日志   | CRITICAL |
| V. RESTful      | API设计规范          | HIGH     |
| VI. 生产就绪    | 错误处理、事务管理   | HIGH     |
| VIII. 简洁性    | YAGNI、依赖管理      | MEDIUM   |
| IX. 事件驱动    | 事件监听、幂等性     | HIGH     |

**合规检查输出示例**：

```markdown
## Architecture Compliance Check

| 原则        | 适用性 | 检查结果 | 说明                         |
| ----------- | ------ | -------- | ---------------------------- |
| I. TDD      | ✓      | ✅       | 已规划单元测试和集成测试     |
| III. 微服务 | ✓      | ⚠️       | 技术栈合规，分层需调整       |
| IV. 安全    | ✓      | ✅       | 已规划输入校验和审计日志     |

**处理规则**: ✅全部合规→继续 | ⚠️需调整→修改后继续 | ❌违规→阻止流程
```

#### 2.1.5 知识生命周期管理

**Feature Registry（特性注册表）** 解决文档"一次性使用"问题，实现历史决策复用和跨需求关联：

**数据结构示例**：

```json
{
  "version": "1.0",
  "features": [
    {
      "id": "user-authentication",
      "name": "用户认证系统",
      "status": "implemented",
      "summary": {
        "business_goal": "实现安全的用户登录和会话管理",
        "technical_approach": "JWT + OAuth2.0",
        "key_decisions": [
          "使用 JWT 而非 Session 存储",
          "Token 有效期 24 小时"
        ]
      },
      "impact": {
        "modules_created": ["auth-service"],
        "apis_added": ["/api/v1/auth/login"]
      },
      "related_features": ["user-registration"],
      "adr_refs": ["ADR-001-jwt-token-strategy"]
    }
  ]
}
```

**知识沉淀命令：/speckit.archive** 在 `/speckit.implement` 完成后自动执行：

1. **知识提取**：解析 [spec.md](http://spec.md)、[plan.md](http://plan.md)、代码变更
2. **知识沉淀**：更新 Feature Registry、生成 ADR、更新领域模型
3. **关联建立**：识别相关特性，更新索引

### 2.2 TDD 测试驱动开发【核心】

#### 2.2.1 TDD 三定律

1. **先写失败测试**：在编写任何生产代码之前，先编写一个失败的单元测试
2. **仅写足够代码**：只编写刚好能让测试通过的生产代码
3. **重构保持测试**：重构代码时确保所有测试仍然通过

#### 2.2.2 红灯-绿灯-重构循环

```plaintext
┌─────────────────────────────────────────────────────┐
│              TDD 循环                                │
├─────────────────────────────────────────────────────┤
│                                                     │
│      ┌─────────┐                                    │
│      │  红灯   │ ← 编写失败测试                      │
│      │  RED    │                                    │
│      └────┬────┘                                    │
│           │                                         │
│           ▼                                         │
│      ┌─────────┐                                    │
│      │  绿灯   │ ← 最小代码通过测试                  │
│      │  GREEN  │                                    │
│      └────┬────┘                                    │
│           │                                         │
│           ▼                                         │
│      ┌─────────┐                                    │
│      │  重构   │ ← 优化设计保持绿灯                  │
│      │ REFACTOR│                                    │
│      └────┬────┘                                    │
│           │                                         │
│           └─────────→ 回到红灯                       │
│                                                     │
└─────────────────────────────────────────────────────┘
```

#### 2.2.3 AI 优先 TDD 流程

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                AI 优先 TDD 流程                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Step 1: 人工编写测试签名和意图                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ describe('用户注册', () => {                         │   │
│  │   it('应该成功注册新用户', () => {                    │   │
│  │     // 意图: 验证邮箱+密码注册流程                    │   │
│  │   });                                                │   │
│  │ });                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  Step 2: AI 生成完整测试用例                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ it('应该成功注册新用户', async () => {               │   │
│  │   const user = { email: 'test@example.com', ... };   │   │
│  │   const result = await registerUser(user);           │   │
│  │   expect(result.success).toBe(true);                 │   │
│  │ });                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  Step 3: AI 编写通过测试的实现代码                          │
│                          ↓                                  │
│  Step 4: 人工审查和验证                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.4 测试金字塔

```plaintext
                    ┌─────────┐
                    │  E2E    │  10%
                    │  测试   │
                ┌───┴─────────┴───┐
                │   集成测试       │  30%
            ┌───┴─────────────────┴───┐
            │       单元测试           │  60%
            └─────────────────────────┘
```

**测试覆盖率要求**：≥80%

### 2.3 AI 协同开发流程

#### 2.3.1 需求阶段

| 活动     | 负责人     | AI参与方式              | 产出         |
| -------- | ---------- | ----------------------- | ------------ |
| 需求分析 | 产品经理   | LLM分析原始需求         | 用户故事草稿 |
| 任务拆解 | 技术负责人 | AI辅助拆解              | 任务列表     |
| 技术方案 | 架构师     | Vibe-Driven Development | 技术规格     |

**Vibe-Driven Development 流程**：

```plaintext
高阶概念 (Vibe)
    ↓ AI对话迭代
技术规格 (Spec)
    ↓ AI对话迭代
实现路径 (Path)
```

#### 2.3.2 开发阶段

**人机结对编程规范**：

| 角色         | 职责                                              |
| ------------ | ------------------------------------------------- |
| **AI** | 样板代码生成、API调用实现、单元测试生成、文档生成 |
| **人** | 业务逻辑设计、架构决策、代码审查、最终验收        |

**从规格生成代码**：

```plaintext
OpenAPI/Swagger  →  API客户端 + 服务器路由
GraphQL Schema   →  类型定义 + Resolver骨架
数据库DDL       →  ORM模型 + Repository层
```

#### 2.3.3 Code Review 阶段

**Code Review 的核心目的**：

1. 让代码更加统一、规范、易维护
2. 方便开发人员互相学习经验，达到知识共享
3. 帮助开发人员跳出固定思维，得出最优解决思路
4. 从可运行到可重用

**双层 CR 机制**：

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                    双层 CR 机制                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  第一层: AI 自动化 Review                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 代码风格检查                                       │   │
│  │ • 潜在 Bug 检测                                      │   │
│  │ • 最佳实践建议                                       │   │
│  │ • 安全漏洞扫描                                       │   │
│  │ • 性能问题识别                                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  第二层: 人类 Reviewer                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 架构一致性                                         │   │
│  │ • 业务逻辑正确性                                     │   │
│  │ • 系统可扩展性                                       │   │
│  │ • 设计模式合理性                                     │   │
│  │ • 领域建模正确性                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Code Review 完整流程**：

```plaintext
1. 开发者提交代码
       ↓
2. 自我 Review（开发者自查基本规范），与SDD流程绑定
       ↓
3. AI 自动化 Review（CI触发）
       ↓
4. 同行 Review（团队成员审查）
       ↓
5. 讨论与修改（针对意见修改）
       ↓
6. 二次 Review（重大问题修改后）
       ↓
7. 合并代码
```

**Code Review 检查清单**：

| 检查维度           | 检查项                                           |
| ------------------ | ------------------------------------------------ |
| **功能性**   | 代码是否实现需求功能、边界条件处理、逻辑错误检查 |
| **设计性**   | 是否符合SOLID原则、职责划分合理性、避免过度设计  |
| **代码质量** | 可读性、命名清晰度、注释充分性                   |
| **性能安全** | 性能瓶颈、资源释放、安全漏洞                     |

---

## 第三章：代码设计规范

### 3.1 三阶段编程方法论

优秀的代码设计需要经历三个阶段：**分析 → 设计 → 打磨**

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                    三阶段编程                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐       │
│  │   分析阶段   │ → │   设计阶段   │ → │   打磨阶段   │       │
│  │             │   │             │   │             │       │
│  │ • 分析需求   │   │ • 分配职责   │   │ • 选择模式   │       │
│  │ • 识别实体   │   │ • GRASP原则  │   │ • 提高可读   │       │
│  │ • 找核心概念 │   │ • 确保清晰   │   │ • 优化维护   │       │
│  └─────────────┘   └─────────────┘   └─────────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**各阶段要点**：

- **分析阶段**：不要急于实现功能，避免陷入事务脚本模式（面向过程），核心是"找实体"
- **设计阶段**：将职责合理分配到各个实体上，运用 GRASP 原则指导设计
- **打磨阶段**：选择合适的设计模式实现，提高代码的可读性和可维护性

### 3.2 SOLID 设计原则

SOLID 是面向对象设计的五大基本原则，是编写高质量代码的基石：

#### 3.2.1 单一职责原则 (SRP)

**定义**：一个类只负责完成一个职责或功能，不应存在多于一种导致类变更的原因。

**优势**：

- 提高类的内聚性
- 降低代码耦合性
- 使代码更易于理解和维护

**注意**：不要过度拆分，否则会降低内聚性，影响可维护性

#### 3.2.2 开放-关闭原则 (OCP)

**定义**：对扩展开放，对修改关闭。添加新功能应通过扩展代码而非修改已有代码。

**实现方式**：

- 使用多态
- 依赖注入
- 基于接口而非实现编程
- 应用设计模式（装饰、策略、模板、职责链、状态等）

#### 3.2.3 里氏替换原则 (LSP)

**定义**：子类对象能够替换程序中父类对象出现的任何地方，并保证原有程序逻辑行为不变。

**核心要求**：

- 子类可以扩展父类功能
- 子类不能改变父类原有功能
- 父类已实现的方法是规范和契约

#### 3.2.4 接口隔离原则 (ISP)

**定义**：调用方不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

**判断标准**：如果调用者只使用部分接口或接口的部分功能，说明接口设计不够职责单一。

#### 3.2.5 依赖反转原则 (DIP)

**定义**：

- 高层模块不应该依赖低层模块，二者都应该依赖其抽象
- 抽象不应该依赖细节，细节应该依赖抽象

**实践**：面向接口编程，而不是面向实现编程

#### 3.2.6 其他重要原则

| 原则                   | 说明                                             |
| ---------------------- | ------------------------------------------------ |
| **迪米特法则**   | 一个对象应该对其他对象保持最少的了解，降低耦合度 |
| **合成复用原则** | 尽量使用组合/聚合方式，而不是使用继承            |

### 3.3 设计模式应用指南

设计模式是经过验证的问题解决方案，核心思想是"**找到变化，封装变化**"。

#### 创建型模式

| 模式             | 说明                                 | 适用场景                     |
| ---------------- | ------------------------------------ | ---------------------------- |
| **单例**   | 一个类只允许创建一个实例             | 无状态/全局唯一/控制资源访问 |
| **工厂**   | 创建相关对象，使用者不关心具体实现类 | 分离对象创建和使用           |
| **建造者** | 创建复杂对象，通过设置可选参数定制化 | 构造参数较多且多数可选       |
| **原型**   | 通过复制已有对象创建新对象           | 对象创建成本大且差别不大     |

#### 结构型模式

| 模式             | 说明                                     | 适用场景                    |
| ---------------- | ---------------------------------------- | --------------------------- |
| **代理**   | 不改变原始类情况下，通过代理类附加功能   | 监控、缓存、限流、事务、RPC |
| **装饰者** | 不改变原始类情况下，通过组合动态扩展功能 | 动态扩展类的功能            |
| **适配器** | 不改变原始类情况下，使其适配新接口       | 复用现有类，但接口不适配    |
| **桥接**   | 多个独立变化维度时，通过组合独立扩展     | 存在多维度继承体系          |
| **门面**   | 为子系统定义更高层接口，使其更易使用     | 解决接口复用性与易用性矛盾  |
| **组合**   | 将对象组合成树形结构，统一处理           | 满足部分-整体树形结构       |
| **享元**   | 运用共享技术支持大量细粒度对象           | 大量对象且字段取值范围固定  |

#### 行为型模式

| 模式             | 说明                               | 适用场景                            |
| ---------------- | ---------------------------------- | ----------------------------------- |
| **观察者** | 主题对象状态变化时通知所有观察者   | 解耦事件创建者与接收者              |
| **模板**   | 定义算法骨架，延迟某些步骤到子类   | 解决复用与扩展问题                  |
| **策略**   | 封装一组算法，使其可互相替换       | 消除if-else，解耦策略定义/创建/使用 |
| **状态**   | 对象内部状态改变时改变其行为       | 分离对象状态与行为                  |
| **职责链** | 对象连成链，请求沿链传递直到被处理 | 解耦请求发送者与接收者              |
| **迭代器** | 顺序访问集合元素，不暴露内部表示   | 解耦集合内部表示与遍历访问          |
| **命令**   | 将请求封装成命令对象，控制执行过程 | 异步、延迟、排队、撤销、存储命令    |

---

## 第四章：编码技巧规范

### 4.1 方法级优化技巧

#### 4.1.1 提炼方法与意图导向编程

**适用场景**：

- 多个方法代码重复
- 方法中代码过长（一般不超过80行）
- 方法中语句不在同一抽象层级

**意图导向编程原则**：

- 将处理流程和具体实现分离
- 把问题分解为一系列功能性步骤
- 假定功能步骤已实现，先组织整体流程
- 最后再实现各个具体方法

#### 4.1.2 其他方法级技巧

| 技巧                                | 说明                                           |
| ----------------------------------- | ---------------------------------------------- |
| **以函数对象取代函数**        | 将大型函数放进单独对象中，局部变量变成对象字段 |
| **引入参数对象**              | 方法参数较多时，将参数封装为参数对象           |
| **移除对参数的赋值**          | 有返回值的方法不应有副作用，避免修改参数值     |
| **引入解释性变量**            | 将复杂表达式结果放入临时变量，用变量名解释用途 |
| **try-catch内部代码抽成方法** | 保持核心逻辑清晰                               |

### 4.2 条件判断优化

#### 4.2.1 使用卫语句替代嵌套条件

**原则**：把复杂的条件表达式拆分成多个条件表达式，减少嵌套。

```plaintext
// 反例：多层嵌套
if (condition1) {
    if (condition2) {
        if (condition3) {
            // 核心逻辑
        }
    }
}

// 正例：卫语句
if (!condition1) return;
if (!condition2) return;
if (!condition3) return;
// 核心逻辑
```

**优势**：降低复杂度、提高可读性、核心逻辑更清晰

#### 4.2.2 使用多态替代条件判断

**适用场景**：当存在根据对象类型选择不同行为的条件表达式时

**实现方式**：

- 将每个分支放进子类内的覆写方法
- 将原始函数声明为抽象函数
- 利用多态机制自动选择正确的实现

### 4.3 异常处理规范

#### 4.3.1 使用异常替代返回错误码

**原则**：非正常业务状态使用抛出异常方式，而不是返回错误码。

**实施要点**：

- 通过最上层统一处理异常，转换成标准返回码
- 不要使用异常处理正常的业务流程控制
- 尽量使用标准异常
- 避免在 finally 语句块中抛出异常
- finally 块中只做关闭资源类操作

**典型模式**：

```plaintext
1. 业务逻辑层抛出业务异常
       ↓
2. 服务层简单调用，不处理异常
       ↓
3. 控制层（Controller/Filter）统一拦截处理异常
```

#### 4.3.2 引入断言

**使用原则**：

- 只用于检查"一定必须为真"的条件
- 不用于检查"应该为真"的条件
- 如果断言条件不满足，代码仍能正常运行，则去掉断言

### 4.4 空值处理

#### 4.4.1 引入 Null 对象或特殊对象

**问题**：频繁的判空操作影响代码美观和可读性，增加 Bug 几率

**解决方案**：

- 创建一个特殊的空对象类
- 空对象提供默认的安全行为
- 使用 Optional 优雅处理

**空指针产生原因**：

- 数据库查询结果为 null
- 集合/数组访问越界
- 对象方法调用时对象为 null

### 4.5 类设计优化

#### 4.5.1 提炼类

**适用场景**：

- 类包含大量数据和函数
- 逻辑复杂不易理解
- 职责不断增加

**判断依据**：

- 某些数据和方法总是一起出现
- 某些数据经常同时变化
- 子类化只影响类的部分特性

**原则**：高内聚低耦合

#### 4.5.2 组合优先于继承

**继承的局限性**：

- 打破封装性
- 子类依赖父类实现细节
- 父类变化可能破坏子类

**组合的优势**：

- 通过私有域引用现有类实例
- 不依赖现有类实现细节
- 更加稳固和灵活

**使用场景判断**：

- 仅当存在真正的"is-a"关系时使用继承
- 包内部使用继承是安全的
- 其他情况优先考虑组合

#### 4.5.3 接口优于抽象类

**接口优势**：

- 现有类可以轻松实现新接口
- 是定义混合类型的理想选择
- 允许构造非层次结构的类型框架

**最佳实践**：接口 + 骨架实现类（模板方法设计模式）

### 4.6 泛型使用规范

| 规范                         | 说明                                    |
| ---------------------------- | --------------------------------------- |
| **优先考虑泛型**       | 编译时类型安全、避免类型转换            |
| **不要使用原生态类型** | 使用原生态类型会失去泛型优势            |
| **消除非受检警告**     | 每条警告都表示可能的 ClassCastException |
| **PECS 原则**          | Producer-Extends, Consumer-Super        |

### 4.7 代码质量提升技巧

| 技巧                                 | 说明                               |
| ------------------------------------ | ---------------------------------- |
| **优先使用模板/工具类**        | 减少重复代码，专注业务逻辑         |
| **分离对象的创建与使用**       | 工厂模式、构建器模式、依赖注入     |
| **可访问性最小化**             | 尽可能使每个类和成员不被外界访问   |
| **可变性最小化**               | 不可变类简单、线程安全、可自由共享 |
| **静态成员类优于非静态成员类** | 非静态成员类会隐式持有外部类引用   |

### 4.8 参数校验与返回规范

#### 4.8.1 优雅地参数校验

**格式校验**：

- 使用 hibernate-validator 框架
- 在实体类上使用 @NotBlank、@NotNull 等注解
- Controller 方法上使用 @Valid 注解

**业务校验**：

- 自定义校验注解
- 实现 ConstraintValidator 接口

#### 4.8.2 统一返回值

**原则**：

- 所有接口使用统一的返回值结构
- 包含状态码、消息、数据等标准字段
- 便于接口调用方统一解析

#### 4.8.3 统一异常处理

**实现方式**：

- 使用 @ControllerAdvice
- 使用 @ExceptionHandler
- 统一转换异常为标准返回格式

### 4.9 并发编程规范

| 规范                                  | 说明                                        |
| ------------------------------------- | ------------------------------------------- |
| **涉及线程间可见性加 volatile** | 保证线程间的可见性                          |
| **减小锁使用范围**              | 只给需要加锁的代码加锁，在 finally 中释放锁 |
| **分布式锁规范**                | 必须设置过期时间和获取锁的超时时间          |

### 4.10 性能优化技巧

| 技巧                                    | 说明                             |
| --------------------------------------- | -------------------------------- |
| **集合指定初始化大小**            | 避免扩容消耗性能                 |
| **不要使用 BeanUtils 拷贝属性**   | 基于反射性能较差，使用 MapStruct |
| **使用 StringBuilder 拼接字符串** | 减少对象创建                     |
| **不循环调用数据库**              | 批量查询 + 转换为 Map + 内存匹配 |
| **用业务代码代替多表 join**       | 在应用层进行数据关联             |
| **远程接口调用设置超时时间**      | 防止线程"卡死"                   |

### 4.11 其他最佳实践

| 实践                             | 说明                                    |
| -------------------------------- | --------------------------------------- |
| **尽量使用工具类**         | CollectionUtils、StringUtils、Hutool 等 |
| **面向接口编程**           | 引用父类或抽象，而非实现                |
| **魔法值用常量表示**       | 提高可读性，便于维护                    |
| **有类型区分时定义好枚举** | 避免魔法数字，提供类型安全              |
| **写好代码注释**           | 解释为什么这样做，而不是怎么做          |

---

## 第五章：多级知识空间

### 5.1 三层架构体系

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                    企业级 (L0)                              │
│              (Enterprise Standards)                         │
│   ┌──────────────┐ ┌──────────────┐ ┌──────────────┐       │
│   │  技术宪法     │ │  编码规范     │ │  技术雷达     │       │
│   └──────────────┘ └──────────────┘ └──────────────┘       │
├─────────────────────────────────────────────────────────────┤
│                    项目级 (L1)                              │
│              (Project Knowledge)                            │
│   ┌──────────────┐ ┌──────────────┐ ┌──────────────┐       │
│   │  业务领域     │ │  服务目录     │ │  架构决策     │       │
│   │  领域模型     │ │  依赖拓扑     │ │  数据流图     │       │
│   └──────────────┘ └──────────────┘ └──────────────┘       │
├─────────────────────────────────────────────────────────────┤
│                    仓库级 (L2)                              │
│              (Repository Context)                           │
│   ┌──────────────┐ ┌──────────────┐ ┌──────────────┐       │
│   │  仓库A        │ │  仓库B        │ │  仓库C        │       │
│   │  context.md  │ │  context.md  │ │  context.md  │       │
│   └──────────────┘ └──────────────┘ └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 L0 企业级知识库

**职责**：企业级强制规范、跨项目统一标准

**目录结构**：

```plaintext
enterprise-standards/
├── constitution/               # 技术宪法
│   ├── architecture-principles.md
│   ├── security-baseline.md
│   └── compliance-requirements.md
├── standards/                  # 编码规范
│   ├── coding-standards/
│   │   ├── java.md
│   │   ├── typescript.md
│   │   └── python.md
│   ├── api-design-guide.md
│   └── testing-standards.md
└── technology-radar/           # 技术雷达
    ├── adopt.md               # 推荐采用
    ├── trial.md               # 试用阶段
    ├── assess.md              # 评估阶段
    └── hold.md                # 暂缓使用
```

**维护方式**：架构委员会统一维护

### 5.3 L1 项目级知识库

**职责**：跨仓库业务知识、项目级架构决策、AI定期聚合

**目录结构**：

```plaintext
project-knowledge/
├── README.md                   # 项目总览
├── BUSINESS.md                 # 业务知识入口
├── ARCHITECTURE.md             # 架构知识入口
│
├── business/                   # 业务领域知识
│   ├── domain-model.md        # 领域模型
│   ├── glossary.md            # 术语词典
│   ├── workflows/             # 业务流程
│   └── rules.md               # 业务规则
│
├── architecture/               # 架构知识
│   ├── service-catalog.md     # 服务目录
│   ├── repo-map.md            # 仓库地图
│   ├── data-flow.md           # 数据流图
│   ├── tech-stack.md          # 技术栈
│   └── decisions/             # 架构决策记录
│       ├── ADR-001-microservices.md
│       └── ADR-002-event-driven.md
│
├── standards/                  # 项目规范（继承L0）
│   ├── coding.md
│   ├── api.md
│   └── testing.md
│
└── aggregated/                 # AI聚合区（自动生成）
    ├── last-updated.json
    ├── repo-summaries/        # 各仓库摘要
    ├── service-topology.md    # 服务拓扑
    └── cross-repo-patterns.md # 跨仓库模式
```

**维护方式**：AI聚合 + 人工审核

### 5.4 L2 仓库级知识库

**设计原则**：

- **极简原则**：只保留仓库特有信息
- **继承原则**：通用规范从上层继承
- **自动化原则**：code-derived 由 AI 自动生成，减轻人工维护成本

**目录结构**：

```plaintext
{repo}/
├── CLAUDE.md                    # AI入口（必须）
└── .knowledge/
    ├── context.md               # 仓库上下文（必须，人工维护）
    ├── decisions.md             # 重要决策记录（可选）
    │
    ├── upstream/                # 上级知识库（Git Subtree 引入）
    │   ├── L1-project/          # 项目级知识库
    │   └── L0-enterprise/       # 企业级知识库
    │
    ├── features/                # 特性知识沉淀（自动维护）
    │   ├── registry.json        # Feature Registry
    │   └── {feature-id}/        # 各功能归档目录
    │
    ├── .knowledge-config.yaml   # 知识库配置
    │
    └── code-derived/            # 代码衍生文档（AI自动生成）
        ├── metadata.json        # 生成元信息
        ├── overview.md          # 仓库概览
        ├── module_tree.json     # 模块依赖树
        └── {module-name}.md     # 各模块详细文档
```

[**context.md**](http://context.md)** 模板**：

```markdown
# 仓库上下文: {repo-name}

## 1. 仓库定位
- **职责**: [一句话描述核心职责]
- **所属项目**: [项目名]
- **上游依赖**: [依赖的仓库/服务]
- **下游消费者**: [谁调用我]

## 2. 技术栈
- 语言: Java 17
- 框架: Spring Boot 3.2
- 数据库: PostgreSQL 14
- 特殊依赖: Redis, RabbitMQ

## 3. 核心模块
| 模块 | 职责 | 主要类 |
|------|------|--------|
| user-api | 用户接口层 | UserController |
| user-service | 业务逻辑层 | UserService |

## 4. 本仓库特有规则
- 用户ID必须使用雪花算法生成
- 密码必须加密存储，使用 bcrypt
- 所有接口需要支持幂等性
```

#### 5.4.1 CodeWiki 自动生成工具

**工具定位**：CodeWiki 是端到端的 AI 驱动文档生成平台，自动分析代码仓库的结构、依赖关系与模块层次，为每个模块生成高质量技术文档。

**核心能力**：

| 能力                   | 说明                                | 技术实现               |
| ---------------------- | ----------------------------------- | ---------------------- |
| **多语言分析**   | 支持 Python、JS/TS、Java、C#、C/C++ | AST + Tree-sitter      |
| **依赖图构建**   | 识别调用关系、构建模块依赖树        | DependencyGraphBuilder |
| **渐进式生成**   | 叶子模块 → 父模块 → 仓库概览      | 动态规划 + 拓扑排序    |
| **缓存增量更新** | 避免重复分析，支持秒级返回          | 文件哈希 + 变更检测    |

**CLI 命令**：

```bash
# 安装
pip install codewiki

# 配置 AI 服务
codewiki config set --api-key <key> --base-url <url>

# 一键生成文档
codewiki generate https://github.com/org/repo --output .knowledge/code-derived/

# 高级选项
codewiki generate /path/to/repo \
  --create-branch           # 创建文档分支
  --github-pages            # 输出为静态站点
  --model gpt-4             # 指定模型
</url></key>
```

#### 5.4.2 上级知识库引用方案（Git Subtree）

L2 仓库级知识库通过 **Git Subtree** 引入 L1 项目级和 L0 企业级知识库，实现对 AI 的透明访问。

**选择 Git Subtree 的理由**：

1. **AI 零障碍访问** - 文件直接存在于仓库，AI 可直接读取
2. **简化 CI/CD** - 无需 `--recursive` 或 submodule 初始化步骤
3. **离线友好** - clone 后即可完整访问所有知识库内容
4. **历史可追溯** - 可选择保留或 squash 上游历史

**操作命令**：

```bash
# 添加远程仓库
git remote add L1-knowledge git@github.com:org/project-knowledge.git

# 首次引入 subtree
git subtree add --prefix=.knowledge/upstream/L1-project L1-knowledge main --squash

# 更新 Subtree
git subtree pull --prefix=.knowledge/upstream/L1-project L1-knowledge main --squash
```

### 5.5 信息流向机制

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                    信息流向                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  自底向上生成 (Upward Aggregation)                          │
│  ─────────────────────────────────                          │
│  仓库级 (L2)  ───AI定期聚合───→  项目级 (L1)  ───→  企业级  │
│                                                             │
│  • 收集 context.md 变更                                     │
│  • 收集 code-derived 文档                                   │
│  • 分析变更影响                                             │
│  • 生成聚合报告                                             │
│                                                             │
│  自顶向下继承 (Downward Inheritance)                        │
│  ─────────────────────────────────                          │
│  企业级 (L0)  ───规范传递───→  项目级 (L1)  ───→  仓库级    │
│                                                             │
│  • 编码规范继承                                             │
│  • 技术选型约束                                             │
│  • 安全基线要求                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.6 AI 聚合机制

**聚合流程**：

```plaintext
1. 收集阶段
   ├── 克隆/拉取各子仓库
   ├── 读取 .knowledge/context.md
   ├── 读取 .knowledge/code-derived/
   └── 与上次快照对比，识别变更

2. 分析阶段 (AI驱动)
   ├── 变更分类 (API/领域模型/架构/配置)
   ├── 影响分析 (哪些项目文档需更新)
   ├── 冲突检测 (多仓库修改同一概念)
   └── 生成分析报告

3. 更新阶段 (AI驱动)
   ├── 根据分析结果更新项目文档
   ├── 保持文档风格一致
   ├── 标注变更来源
   └── 验证交叉引用

4. 审核阶段
   ├── 自动创建 PR
   ├── 低风险变更自动合并
   ├── 高风险变更人工审核
   └── 发送通知 (Slack/邮件)
```

---

## 第六章：统一工具链

### 6.1 AI 编码工具

#### 6.1.1 核心 IDE 和 Agent

| 工具                      | 定位       | 使用场景                  |
| ------------------------- | ---------- | ------------------------- |
| **Claude Code CLI** | Base Agent | 主力开发工具，支持MCP集成 |
| **Cursor**          | AI编辑器   | 日常编码，代码补全        |
| **GitHub Copilot**  | 代码补全   | 辅助编码，代码建议        |

#### 6.1.2 Agent 架构

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                    Agent 架构                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                 Claude Code (Base Agent)             │   │
│  │  • 子Agent调度                                       │   │
│  │  • MCP集成                                           │   │
│  │  • 通用开发工具                                      │   │
│  │  • 上下文压缩                                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│          ┌───────────────┼───────────────┐                 │
│          ▼               ▼               ▼                 │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐       │
│  │ Coding Agent │ │  Test Agent  │ │ Deploy Agent │       │
│  └──────────────┘ └──────────────┘ └──────────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 开发工具集成 (MCP)

通过 MCP（Model Context Protocol）将分散的工具集成：

| MCP Server           | 功能         | 触发场景            |
| -------------------- | ------------ | ------------------- |
| **Context7**   | 官方文档查询 | 框架API、库使用方法 |
| **Sequential** | 复杂推理     | 调试、系统设计      |
| **Serena**     | 语义理解     | 符号操作、项目导航  |
| **Playwright** | 浏览器测试   | E2E测试、UI验证     |

### 6.3 代码理解能力

**三层代码理解**：

| 层级                     | 方案              | 目的             |
| ------------------------ | ----------------- | ---------------- |
| **目标仓库定位**   | 知识库RAG         | 快速定位目标仓库 |
| **跨仓库依赖召回** | RAG + Git增量更新 | 召回依赖代码     |
| **工作区代码理解** | 文本搜索 + AST    | 精确理解当前代码 |

#### 6.3.1 代码分析技术栈

**语言分析器选型**：

| 语言                 | 分析技术    | 分析器                     | 提取能力                         |
| -------------------- | ----------- | -------------------------- | -------------------------------- |
| **Python**     | 原生 AST    | `ast` 模块               | 类、函数、导入、装饰器、类型注解 |
| **JavaScript** | Tree-sitter | `tree-sitter-javascript` | 函数、类、模块导出、JSDoc        |
| **TypeScript** | Tree-sitter | `tree-sitter-typescript` | 类型定义、接口、泛型、装饰器     |
| **Java**       | Tree-sitter | `tree-sitter-java`       | 类、方法、注解、包结构           |
| **C#**         | Tree-sitter | `tree-sitter-c-sharp`    | 类、方法、属性、命名空间         |
| **C/C++**      | Tree-sitter | `tree-sitter-c/cpp`      | 函数、结构体、宏、头文件         |

### 6.4 长期记忆系统

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                    长期记忆系统                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐ │
│  │ 记忆提取 │ → │ 记忆存储 │ → │ 记忆召回 │ → │跨会话复用│ │
│  │          │   │          │   │          │   │          │ │
│  │ 开发者与 │   │ 结构化   │   │ 相似场景 │   │ 知识持续 │ │
│  │ Agent对话│   │ 索引存储 │   │ 匹配召回 │   │ 积累     │ │
│  └──────────┘   └──────────┘   └──────────┘   └──────────┘ │
│                                                             │
│  效果对比:                                                  │
│  • 未接入记忆: 5-10轮对话修正                               │
│  • 接入记忆: 1-3轮对话                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.5 质量工具链

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                    质量工具链                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  静态分析          安全扫描           测试框架              │
│  ┌──────────┐     ┌──────────┐      ┌──────────┐           │
│  │ ESLint   │     │ Snyk     │      │ Jest     │           │
│  │ SonarQube│     │ AI SAST  │      │ Pytest   │           │
│  │ DeepCode │     │ 敏感信息 │      │Playwright│           │
│  └──────────┘     └──────────┘      └──────────┘           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.6 CI/CD 集成

| 功能                    | 说明           | AI参与方式              |
| ----------------------- | -------------- | ----------------------- |
| **自动化部署**    | 持续集成部署   | AI生成部署脚本          |
| **Release Notes** | 版本发布说明   | AI根据PR/Commit自动生成 |
| **风险预测**      | 高风险变更预警 | AI分析代码变动预测风险  |
| **质量门禁**      | 代码质量检查   | AI辅助代码审查          |

### 6.7 前端 AI Coding 模式

#### 6.7.1 推荐模式：Figma MCP 实时访问

**核心优势**：

| 维度         | Figma MCP      | 传统导出模式   | 效率提升              |
| ------------ | -------------- | -------------- | --------------------- |
| 单次代码生成 | 5分钟          | 20分钟         | **节省75%**     |
| 设计变更响应 | 即时刷新       | 重新导出流程   | **快4倍**       |
| 月度维护成本 | 1.5人天        | 11.5人天       | **省10人天/月** |
| 代码质量     | AI理解设计语义 | 固定尺寸硬编码 | **返工率低60%** |

**ROI分析**（5人团队年度）：

- 年度节省：120人天 ≈ 0.5个全职开发产出
- 3年净收益：$152,750
- 首月即可回本，ROI达549%

#### 6.7.2 工作流程

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                Figma MCP 前端开发流程                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  设计师                    AI Agent                开发者    │
│  ┌─────────┐              ┌─────────┐            ┌─────────┐│
│  │ Figma   │ ──MCP实时──→ │ 读取    │ ──生成──→ │ 审查    ││
│  │ 设计稿  │   访问       │ 设计稿  │   代码     │ 优化    ││
│  └─────────┘              └─────────┘            └─────────┘│
│       │                        │                      │     │
│       └────────────────────────┼──────────────────────┘     │
│                                │                            │
│                    设计变更即时同步，无需手工导出             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 6.7.3 设计规范要求

**命名规范**（设计师必须遵循）：

| 层级 | 命名规则             | 示例                       |
| ---- | -------------------- | -------------------------- |
| 页面 | `Page/功能模块`    | `Page/UserProfile`       |
| 组件 | `Component/组件名` | `Component/Button`       |
| 元素 | `语义化名称`       | `title`, `description` |

**设计系统要求**：

- 使用Auto Layout约束（AI生成响应式布局）
- 定义Design Token（颜色、字体、间距）
- 组件使用Variants标注状态

---

## 第七章：质量保障

### 7.1 SDD 质量门禁

| 检查项     | 标准             | 检查方式     |
| ---------- | ---------------- | ------------ |
| 规格完整性 | 必填字段100%覆盖 | 自动化校验   |
| 接口一致性 | 规格与实现一致   | Contract测试 |
| 设计评审   | 评审通过         | 人工评审     |

### 7.2 TDD 质量门禁

| 检查项       | 标准     | 检查方式   |
| ------------ | -------- | ---------- |
| 测试覆盖率   | ≥80%    | 自动化统计 |
| 测试用例评审 | 评审通过 | 人工评审   |
| 回归测试     | 100%通过 | CI自动运行 |

### 7.3 代码质量门禁

| 检查项   | 标准           | 检查方式         |
| -------- | -------------- | ---------------- |
| 静态检查 | 0 Error        | ESLint/SonarQube |
| 安全扫描 | 0 高危漏洞     | Snyk/AI SAST     |
| CR审批   | 至少1人Approve | GitHub PR        |

### 7.4 Agent 评测体系

#### 7.4.1 评测集构造

| 类型                | 来源     | 用途         |
| ------------------- | -------- | ------------ |
| **种子集**    | 人工标注 | 初始评测基准 |
| **Badcase集** | 用户反馈 | 问题修复验证 |
| **扩展集**    | LLM泛化  | 扩大评测覆盖 |
| **对抗集**    | 专门设计 | 边界场景测试 |

#### 7.4.2 评测指标

| 类别               | 指标       | 目标     |
| ------------------ | ---------- | -------- |
| **效果指标** | 任务完成率 | >90%     |
| **效果指标** | 准确率     | >85%     |
| **技术指标** | 响应时间   | <30s     |
| **技术指标** | Token消耗  | 合理范围 |
| **用户指标** | 满意度     | >80%     |
| **用户指标** | 使用频率   | 持续增长 |

### 7.5 AI 辅助文档生成

#### 7.5.1 文档生成能力

| 文档类型                | AI 能力                           | 触发时机     |
| ----------------------- | --------------------------------- | ------------ |
| **代码文档**      | 基于代码生成模块摘要、函数说明    | 代码变更时   |
| **API 文档**      | 生成接口描述、参数说明、示例      | API 变更时   |
| **架构图**        | 生成 Mermaid 语法的系统图、流程图 | 按需或定期   |
| **Release Notes** | 基于 Commit/PR 总结关键变更       | 发布时       |
| **Runbook**       | 生成运维操作手册初稿              | 新服务上线时 |

#### 7.5.2 自动化触发机制

```plaintext
┌─────────────────────────────────────────────────────────────────┐
│                    文档自动化流程                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  触发事件                    AI 动作                  人类动作   │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  PR 合并        ──→  更新受影响模块文档      ──→  审查变更      │
│                                                                 │
│  版本发布       ──→  生成 Release Notes     ──→  确认关键变更   │
│                                                                 │
│  新服务上线     ──→  生成 Runbook 初稿      ──→  验证操作步骤   │
│                                                                 │
│  定期任务       ──→  检测文档与代码一致性   ──→  处理不一致项   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 7.5.3 文档质量门禁

| 检查项 | 标准                   | 检查方式           |
| ------ | ---------------------- | ------------------ |
| 覆盖率 | 公共 API 100% 有文档   | 自动化扫描         |
| 新鲜度 | 代码变更后文档同步更新 | CI 检查            |
| 一致性 | 文档与代码行为一致     | 示例代码可运行测试 |
| 完整性 | 必填字段无遗漏         | 模板校验           |

#### 7.5.4 渐进式文档生成策略

基于代码依赖关系的智能文档生成策略，采用动态规划方法从叶子模块逐步构建到仓库概览：

```plaintext
┌─────────────────────────────────────────────────────────────────┐
│                  渐进式文档生成策略                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  第一步：拓扑排序                                                │
│  根据依赖关系确定处理顺序：被依赖的模块优先处理                    │
│                                                                 │
│  第二步：叶子模块处理                                             │
│  为无子模块的叶子节点生成详细文档                                 │
│  • 类图、函数签名、使用示例                                       │
│                                                                 │
│  第三步：父模块聚合                                               │
│  基于子模块文档生成父模块概述                                     │
│  • 子模块关系、数据流、接口摘要                                   │
│                                                                 │
│  第四步：仓库概览                                                 │
│  基于所有模块文档生成端到端架构概览                               │
│  • 端到端架构图、模块职责矩阵、快速入口                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**模块复杂度判断**：

| 复杂度             | 判断条件            | 生成策略           | Agent 工具                |
| ------------------ | ------------------- | ------------------ | ------------------------- |
| **简单模块** | 组件数 ≤ 3，单文件 | 一次性整体处理     | 文件读取 + LLM            |
| **复杂模块** | 组件数 > 3，多文件  | 拆分组件逐个处理   | 文件读取 + 依赖注入 + LLM |
| **叶子模块** | 无子模块            | 直接生成详细文档   | 完整 Agent 工具链         |
| **父模块**   | 有子模块            | 基于子模块文档聚合 | 子文档读取 + LLM          |

---

## 第八章：实施路径

### 8.1 第一阶段：基础构建（1-2个月）

**目标**：建立基础设施和流程框架

| 任务           | 负责人     | 产出               |
| -------------- | ---------- | ------------------ |
| 建立知识库架构 | 架构师     | 三层知识库目录结构 |
| 编写SDD模板    | 架构师     | Speckit模板集      |
| 配置TDD流程    | 开发Leader | TDD工作流文档      |
| 选型AI工具链   | 技术负责人 | 工具选型报告       |
| 制定开发章程   | 技术负责人 | 开发规范文档       |

### 8.2 第二阶段：流程落地（2-3个月）

**目标**：试点验证并建立评测体系

| 任务            | 负责人     | 产出     |
| --------------- | ---------- | -------- |
| 试点项目验证    | 项目组     | 验证报告 |
| SDD/TDD流程推广 | 开发Leader | 培训材料 |
| AI工具培训      | AI专家     | 培训课程 |
| 质量门禁建立    | QA         | 门禁配置 |
| 评测体系搭建    | AI专家     | 评测平台 |

**试点选择标准**：

- 单职能单仓库
- 日常需求（非紧急）
- 团队积极性高

### 8.3 第三阶段：规模推广（3-6个月）

**目标**：全面推广和工具链整合

| 任务             | 负责人     | 产出       |
| ---------------- | ---------- | ---------- |
| 多职能多仓库需求 | 项目组     | 交付成果   |
| 知识库AI聚合上线 | DevOps     | 聚合系统   |
| 团队全员培训     | 技术负责人 | 培训记录   |
| 工具链整合       | DevOps     | 集成方案   |
| 最佳实践沉淀     | 架构师     | 最佳实践库 |

### 8.4 第四阶段：持续优化（持续进行）

**目标**：持续改进和能力提升

| 任务           | 负责人     | 产出         |
| -------------- | ---------- | ------------ |
| 项目级需求支持 | 项目组     | 交付成果     |
| 长期记忆优化   | AI专家     | 记忆系统升级 |
| 数据驱动改进   | 技术负责人 | 改进报告     |
| AI驱动模式探索 | 架构师     | 探索报告     |
| 效能持续提升   | 团队       | 效能报告     |

---

## 第九章：度量与优化

### 9.1 SDD/TDD 效能指标

| 指标             | 定义                   | 目标 |
| ---------------- | ---------------------- | ---- |
| 规格到代码转化率 | 规格直接生成代码的比例 | >70% |
| 测试先行遵从率   | 先写测试的需求占比     | >90% |
| 设计复用率       | 复用已有设计的比例     | >50% |
| 缺陷逃逸率       | 未被测试发现的缺陷比例 | <5%  |

### 9.2 AI 协作指标

| 指标           | 定义                   | 目标 |
| -------------- | ---------------------- | ---- |
| AI代码采纳率   | AI生成代码被采纳的比例 | >60% |
| AI辅助时间节省 | 相比传统方式节省的时间 | >30% |
| AI生成准确率   | AI首次生成即正确的比例 | >70% |
| 监督对话轮次   | 完成任务所需对话轮次   | <5轮 |

### 9.3 知识库健康指标

| 指标         | 定义                       | 目标  |
| ------------ | -------------------------- | ----- |
| 知识覆盖率   | 代码模块被知识库覆盖的比例 | >90%  |
| 知识新鲜度   | 知识库最后更新时间         | <30天 |
| 聚合准确率   | AI聚合内容正确的比例       | >85%  |
| 开发者满意度 | 对知识库的满意度调研       | >80%  |

### 9.4 综合效能指标

| 指标           | 定义                   | 目标   |
| -------------- | ---------------------- | ------ |
| 开发效能提升率 | 相比传统方式的效率提升 | >30%   |
| 代码质量改善率 | 代码质量指标的改善     | >20%   |
| Bug率下降率    | Bug数量的下降比例      | >25%   |
| 单需求成本     | 每个需求的AI Token成本 | <100元 |

---

## 第十章：风险与应对

### 10.1 技术风险

| 风险       | 影响               | 应对措施          |
| ---------- | ------------------ | ----------------- |
| AI不确定性 | 生成代码质量不稳定 | 评测体系+人工监督 |
| 代码安全   | 敏感信息泄露       | 代码脱敏处理      |
| 工具依赖   | 单一供应商风险     | 多工具备选方案    |

### 10.2 管理风险

| 风险     | 影响             | 应对措施         |
| -------- | ---------------- | ---------------- |
| 期望过高 | 落地效果不及预期 | 明确AI能力边界   |
| 成本失控 | Token费用超预算  | 成本监控+优化    |
| 质量下降 | 追求速度牺牲质量 | 质量门禁强制执行 |

### 10.3 组织风险

| 风险     | 影响           | 应对措施          |
| -------- | -------------- | ----------------- |
| 技能转型 | 开发者适应困难 | 系统培训+渐进推广 |
| 文化冲突 | 抵触AI协作模式 | 试点验证+成功案例 |
| 角色变化 | 工作方式不适应 | 明确新角色定位    |

---

## 第十一章：GitHub 生态全栈方案

本章介绍基于 GitHub 生态的 AI Coding 研发流程完整技术栈，覆盖规划、开发、交付、安全全链路。

### 11.1 技术栈全景

```plaintext
┌─────────────────────────────────────────────────────────────────────┐
│                    GitHub 生态 AI Coding 全栈                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐               │
│  │  规划层     │   │  开发层     │   │  交付层     │               │
│  │             │   │             │   │             │               │
│  │ • Projects  │   │ • Copilot   │   │ • Actions   │               │
│  │ • Issues    │   │ • Workspace │   │ • Packages  │               │
│  │ • Milestones│   │ • Codespaces│   │ • Pages     │               │
│  └──────┬──────┘   └──────┬──────┘   └──────┬──────┘               │
│         │                 │                 │                       │
│         └─────────────────┼─────────────────┘                       │
│                           │                                         │
│  ┌────────────────────────┴────────────────────────┐               │
│  │                 安全与质量层                      │               │
│  │                                                  │               │
│  │  • Secret Protection  • Code Security           │               │
│  │  • Dependabot        • Code Scanning            │               │
│  │  • Push Protection   • Security Campaigns       │               │
│  └──────────────────────────────────────────────────┘               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 11.2 规划层：GitHub Projects + Issues

#### 11.2.1 核心能力

| 能力               | GitHub 工具         | AI 增强                        | 说明                       |
| ------------------ | ------------------- | ------------------------------ | -------------------------- |
| **需求管理** | Issues + Sub-issues | Copilot 自动拆解               | 支持父子层级，复杂项目分解 |
| **看板管理** | Projects (Board)    | 自动化规则                     | 支持 Scrum/Kanban 视图     |
| **路线图**   | Projects (Roadmap)  | -                              | 时间线规划，依赖关系可视化 |
| **任务分配** | Assignees + Copilot | **可直接分配给 Copilot** | Copilot 自主编码、创建 PR  |
| **里程碑**   | Milestones          | -                              | 版本规划，进度跟踪         |

### 11.3 开发层：GitHub Copilot 家族

#### 11.3.1 Copilot 产品矩阵

| 产品                         | 定位                    | 适用场景         | 价格                |
| ---------------------------- | ----------------------- | ---------------- | ------------------- |
| **Copilot Free**       | 基础代码补全            | 个人学习、小项目 | 免费（2000补全/月） |
| **Copilot Pro**        | 完整 AI 编程助手        | 个人开发者       | $10/月              |
| **Copilot Pro+**       | 高级功能 + Coding Agent | 专业开发者       | $39/月              |
| **Copilot Business**   | 团队协作                | 中小团队         | $19/人/月           |
| **Copilot Enterprise** | 企业级 + 知识库         | 大型企业         | $39/人/月           |

#### 11.3.2 Copilot 核心能力

| 能力                     | 说明           | 触发方式              |
| ------------------------ | -------------- | --------------------- |
| **代码补全**       | 智能代码建议   | 自动触发              |
| **Chat**           | 对话式编程助手 | `Ctrl+I` 或侧边栏   |
| **Agent Mode**     | 自主多文件编辑 | Chat 中启用           |
| **Inline Chat**    | 行内代码修改   | 选中代码后 `Ctrl+I` |
| **Explain**        | 代码解释       | 右键菜单              |
| **Fix**            | 自动修复错误   | 错误提示处点击        |
| **Generate Tests** | 生成测试代码   | 右键菜单              |
| **Generate Docs**  | 生成文档注释   | 右键菜单              |

#### 11.3.3 Copilot Workspace 工作流

```plaintext
┌─────────────────────────────────────────────────────────────────────┐
│                  Copilot Workspace 工作流                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐               │
│  │  Issue      │ → │  Spec       │ → │  Plan       │               │
│  │  输入需求   │   │  生成规格   │   │  生成计划   │               │
│  └─────────────┘   └─────────────┘   └─────────────┘               │
│                                              ↓                      │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐               │
│  │  PR         │ ← │  Test       │ ← │  Code       │               │
│  │  提交审查   │   │  运行测试   │   │  生成代码   │               │
│  └─────────────┘   └─────────────┘   └─────────────┘               │
│                                                                     │
│  全程可人工介入编辑，保持完全控制                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 11.3.4 Copilot Coding Agent

将 Issue 直接分配给 Copilot，AI 自主完成编码：

**适用场景**：

| 场景       | 适合度     | 说明                   |
| ---------- | ---------- | ---------------------- |
| Bug 修复   | ⭐⭐⭐⭐⭐ | 明确的问题，有测试验证 |
| 小功能实现 | ⭐⭐⭐⭐   | 边界清晰的独立功能     |
| 重构任务   | ⭐⭐⭐     | 需要清晰的重构指令     |
| 复杂功能   | ⭐⭐       | 建议人工主导，AI 辅助  |
| 架构设计   | ⭐         | 不适合，需人类决策     |

### 11.4 交付层：GitHub Actions

#### 11.4.1 CI/CD 核心能力

| 能力                  | 说明                    | 配额（Team）   |
| --------------------- | ----------------------- | -------------- |
| **构建**        | 多语言构建支持          | 3000分钟/月    |
| **测试**        | 单元测试、集成测试、E2E | 包含在构建配额 |
| **部署**        | 支持所有主流云平台      | 包含在构建配额 |
| **Runners**     | GitHub 托管 / 自托管    | 无限（自托管） |
| **Marketplace** | 25000+ 预置 Actions     | 免费使用       |

#### 11.4.2 AI 增强的 Actions

**Issue 智能分类、PR 自动摘要、每周 Issue 总结** 等 AI 驱动的自动化 Actions 可显著提升团队效率。

### 11.5 安全与质量层

#### 11.5.1 GitHub Security 产品

| 产品                               | 价格      | 核心能力                                         |
| ---------------------------------- | --------- | ------------------------------------------------ |
| **GitHub Secret Protection** | $19/人/月 | 密钥泄露检测、Push 保护、AI 密码检测、自定义模式 |
| **GitHub Code Security**     | $30/人/月 | CodeQL 扫描、Copilot Autofix、安全战役、依赖审查 |
| **Dependabot**               | 免费      | 依赖漏洞告警、自动更新 PR、版本更新              |

### 11.6 与 AI Coding 流程体系集成

#### 11.6.1 流程映射

| AI Coding 流程阶段     | GitHub 工具                                  | 集成方式                                |
| ---------------------- | -------------------------------------------- | --------------------------------------- |
| **SDD 规范驱动** | Issues + Projects                            | Issue 模板定义规格，Projects 管理工作流 |
| **TDD 测试驱动** | Actions + Copilot                            | Actions 运行测试，Copilot 生成测试代码  |
| **Code Review**  | PR + Code Security                           | Copilot 自动审查，CodeQL 安全扫描       |
| **知识库 L2**    | `.copilot-instructions.md` + `AGENTS.md` | 项目级 AI 指令配置                      |
| **文档生成**     | Actions + CodeWiki                           | PR 合并触发文档更新                     |
| **安全保障**     | Secret Protection + Dependabot               | 自动检测密钥泄露和依赖漏洞              |

#### 11.6.2 SDD + GitHub 集成工作流

```plaintext
┌─────────────────────────────────────────────────────────────────────┐
│              SDD + GitHub 集成工作流                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ Issue (需求)                                                 │   │
│  │ • 使用 Issue 模板填写需求                                    │   │
│  │ • AI 自动分类、添加标签                                      │   │
│  │ • 添加到 Projects Board                                      │   │
│  └──────────────────────────┬──────────────────────────────────┘   │
│                              ↓                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ Copilot Workspace / Speckit                                  │   │
│  │ • 从 Issue 生成 Spec (spec.md)                               │   │
│  │ • 生成实施计划 (plan.md)                                     │   │
│  │ • 生成任务列表 (tasks.md)                                    │   │
│  └──────────────────────────┬──────────────────────────────────┘   │
│                              ↓                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ Coding Agent / 人工开发                                      │   │
│  │ • 简单任务：分配给 @copilot 自主完成                         │   │
│  │ • 复杂任务：人工 + Copilot Agent Mode                        │   │
│  └──────────────────────────┬──────────────────────────────────┘   │
│                              ↓                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ Pull Request                                                 │   │
│  │ • Actions 自动运行测试、安全扫描                             │   │
│  │ • AI 生成 PR 摘要                                            │   │
│  │ • Copilot 辅助 Code Review                                   │   │
│  │ • 人工最终审批                                               │   │
│  └──────────────────────────┬──────────────────────────────────┘   │
│                              ↓                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ Merge & Deploy                                               │   │
│  │ • Actions 自动部署                                           │   │
│  │ • CodeWiki 更新知识库                                        │   │
│  │ • Issue 自动关闭                                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 11.7 推荐方案

#### 11.7.1 按团队规模选型

**个人开发者 / 小团队（1-5人）**：

```plaintext
GitHub Free + Copilot Pro ($10/月)
├── Issues + Projects（基础看板）
├── Copilot 代码补全 + Chat
├── Actions（2000分钟/月）
├── Dependabot（免费）
├── Secret Scanning（公开仓库免费）
└── 月成本: ~$10/人
```

**中型团队（5-50人）**：

```plaintext
GitHub Team ($4/人/月) + Copilot Business ($19/人/月)
├── Projects 高级功能
├── Copilot Agent Mode
├── Actions（3000分钟/月）
├── Secret Protection（可选 $19/人/月）
├── Protected Branches + Required Reviews
├── CODEOWNERS
└── 月成本: ~$23-42/人
```

**大型团队 / 企业（50+人）**：

```plaintext
GitHub Enterprise + Copilot Enterprise ($39/人/月)
├── Copilot Workspace + Coding Agent
├── Agent HQ（多 Agent 编排）
├── GitHub Advanced Security（完整套件）
├── SAML SSO + SCIM
├── Audit Log API
├── 自托管 Runners
├── 专属支持
└── 月成本: ~$60-100/人（含 GHAS）
```

#### 11.7.2 实施路径

**第一阶段：基础能力（1-2周）**

- [ ] 配置 `.copilot-instructions.md`
- [ ] 配置 `AGENTS.md`
- [ ] 启用 Dependabot
- [ ] 配置 Issue 模板
- [ ] 建立 Projects 看板

**第二阶段：CI/CD 自动化（2-4周）**

- [ ] 配置 Actions 构建流程
- [ ] 集成测试自动化
- [ ] 启用 CodeQL 扫描
- [ ] 配置 Branch Protection

**第三阶段：AI 深度集成（4-8周）**

- [ ] 启用 Copilot Agent Mode
- [ ] 配置 AI Issue 分类
- [ ] 集成 CodeWiki 文档生成
- [ ] 尝试 Coding Agent 处理简单任务

**第四阶段：持续优化（持续）**

- [ ] 优化 Copilot 指令
- [ ] 完善 Actions 工作流
- [ ] 建立效能度量
- [ ] 迭代改进流程

---

## 附录

### A. 术语表

| 术语             | 定义                                           |
| ---------------- | ---------------------------------------------- |
| **SDD**    | Specification-Driven Development，规范驱动开发 |
| **TDD**    | Test-Driven Development，测试驱动开发          |
| **MCP**    | Model Context Protocol，模型上下文协议         |
| **RAG**    | Retrieval-Augmented Generation，检索增强生成   |
| **ADR**    | Architecture Decision Record，架构决策记录     |
| **HITL**   | Human-In-The-Loop，人工监督                    |
| **GHAS**   | GitHub Advanced Security，GitHub 高级安全      |
| **CodeQL** | GitHub 代码查询语言，用于安全扫描              |

### B. 参考资源

- [Speckit 工作流文档](./speckit/)
- [OpenSpec 变更管理](./openspec/)
- [知识库架构设计](./knowledge-design.md)
- [有赞 AI Coding 实践](../docs-example/youzan-ai-coding.md)
- [OpenAI: 构建 AI 原生工程团队](./openai-native-team.md)
- [GitHub Copilot 文档](https://docs.github.com/copilot)
- [GitHub Actions 文档](https://docs.github.com/actions)
- [GitHub Advanced Security](https://docs.github.com/code-security)

### C. 版本历史

| 版本 | 日期       | 作者     | 变更说明                                                                                      |
| ---- | ---------- | -------- | --------------------------------------------------------------------------------------------- |
| 1.0  | 2025-12-01 | 架构团队 | 初始版本                                                                                      |
| 2.0  | 2025-12-01 | 架构团队 | 新增代码设计规范（SOLID原则、设计模式）、编码技巧规范；完善Code Review流程与检查清单          |
| 2.5  | 2025-12-01 | 架构团队 | 新增知识生命周期管理（Feature Registry、/speckit.archive）、上级知识库引用方案（Git Subtree） |
| 2.7  | 2025-12-01 | 架构团队 | 新增GitHub生态全栈方案（Projects、Copilot、Actions、Security）；完善实施路径与推荐方案        |

---

**报告结束**

本报告定义了一套完整的 AI Coding 研发流程体系，涵盖从需求规划到代码交付的全生命周期，通过 SDD/TDD 双驱动、多级知识空间、统一工具链和完善的质量保障机制，实现人机协同的高效软件研发模式。建议企业根据自身规模和成熟度，选择合适的实施路径，循序渐进地推进 AI Coding 转型。

![AI Coding研发流程体系思维导图](https://cdn.gooo.ai/gen-images/89a7c990f3b040dbe4df27ce342e117f111a67441f3d683613470b72c55495aa.svg)

![AI Coding研发流程体系架构图](https://cdn.gooo.ai/gen-images/07de0a42a50b1a69a06a2563f1718bf31b5c645c42dc568dfedae0215a4ec00f.svg)


![AI Coding端到端研发流程图](https://cdn.gooo.ai/gen-images/915672f7ecb39b987a539fc4a35792d59426fb3cf311cf57a40c25e0988e5ceb.svg)

![D-R-O委派-审查-掌控职责分工表](https://cdn.gooo.ai/gen-images/4216768688479ff413affe909607adae5e66462766904194d2928a65a0184d11.svg)
