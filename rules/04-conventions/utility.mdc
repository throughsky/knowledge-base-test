---
description: 定义工具类的编码标准，包括类结构设计、方法实现和代码质量规范
globs: **/src/main/java/**/utils/**Util.java, **/src/main/java/**/util/**Util.java
layer: L4
allowedReferences: [L4]
---

# Utility 编码约定

## 适用范围
定义工具类的实现规范，提供通用的工具方法或服务。

## 核心规则

### 强制要求（MUST）
- 类名必须以 `Util` 结尾
- 必须添加 JavaDoc 注释
- 必须进行参数验证
- 位置：`util` 或 `utils` 包下

### 禁止要求（MUST NOT）
- 禁止重复造轮子（优先使用成熟库）
- 禁止过度设计
- 禁止缺少异常处理

### 可选要求（MAY）
- 可以使用 `@Component` 注解（Spring组件型）
- 可以使用静态工具类（纯静态型）
- 可以注入配置和依赖

## 完整代码模板

### 文件结构
- 包声明
- 导入语句
- 类声明
- 方法定义

### 完整实现模板
```java
package com.edu.soop.util;

import com.edu.soop.entity.UserEntity;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;

/**
 * JWT工具类
 * 用于JWT令牌的生成、验证和信息提取
 *
 * @author system
 * @since 1.0.0
 */
@Component
@Slf4j
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration:3600}")
    private Long expiration;

    /**
     * 生成JWT令牌
     *
     * @param user 用户实体
     * @return JWT令牌
     */
    public String generateToken(UserEntity user) {
        if (user == null || user.getId() == null) {
            throw new IllegalArgumentException("用户信息不能为空");
        }

        Date now = new Date();
        Date expirationDate = new Date(now.getTime() + expiration * 1000);

        SecretKey key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));

        return Jwts.builder()
                .subject(user.getId().toString())
                .claim("username", user.getUsername())
                .claim("role", user.getRole())
                .issuedAt(now)
                .expiration(expirationDate)
                .signWith(key)
                .compact();
    }

    /**
     * 验证JWT令牌
     *
     * @param token JWT令牌
     * @return 是否有效
     */
    public boolean validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            return false;
        }

        try {
            SecretKey key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
            Jwts.parser()
                    .verifyWith(key)
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (Exception e) {
            log.error("JWT验证失败", e);
            return false;
        }
    }

    /**
     * 从token获取用户ID
     *
     * @param token JWT令牌
     * @return 用户ID
     */
    public Long getUserIdFromToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token不能为空");
        }

        Claims claims = getClaimsFromToken(token);
        return Long.parseLong(claims.getSubject());
    }

    /**
     * 从token获取用户名
     *
     * @param token JWT令牌
     * @return 用户名
     */
    public String getUsernameFromToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token不能为空");
        }

        Claims claims = getClaimsFromToken(token);
        return claims.get("username", String.class);
    }

    /**
     * 从token获取用户角色
     *
     * @param token JWT令牌
     * @return 用户角色
     */
    public String getRoleFromToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token不能为空");
        }

        Claims claims = getClaimsFromToken(token);
        return claims.get("role", String.class);
    }

    /**
     * 从token获取Claims
     *
     * @param token JWT令牌
     * @return Claims对象
     */
    private Claims getClaimsFromToken(String token) {
        try {
            SecretKey key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
            return Jwts.parser()
                    .verifyWith(key)
                    .build()
                    .parseSignedClaims(token)
                    .getPayload();
        } catch (Exception e) {
            log.error("解析JWT令牌失败", e);
            throw new IllegalArgumentException("无效的JWT令牌");
        }
    }
}
```

### 静态工具类模板
```java
package com.edu.soop.util;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * 日期工具类
 * 提供日期格式化和解析功能
 *
 * @author system
 * @since 1.0.0
 */
public final class DateUtil {

    private static final DateTimeFormatter DEFAULT_FORMATTER = 
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    /**
     * 私有构造器，防止实例化
     */
    private DateUtil() {
        // 防止实例化
    }

    /**
     * 格式化日期为字符串
     *
     * @param dateTime 日期时间
     * @return 格式化后的字符串
     */
    public static String format(LocalDateTime dateTime) {
        return dateTime != null ? dateTime.format(DEFAULT_FORMATTER) : null;
    }

    /**
     * 解析日期字符串
     *
     * @param dateStr 日期字符串
     * @return 解析后的日期时间
     */
    public static LocalDateTime parse(String dateStr) {
        if (dateStr == null || dateStr.trim().isEmpty()) {
            return null;
        }
        return LocalDateTime.parse(dateStr, DEFAULT_FORMATTER);
    }

    /**
     * 获取当前时间字符串
     *
     * @return 当前时间字符串
     */
    public static String now() {
        return format(LocalDateTime.now());
    }
}
```

## 规则执行检查清单

### 生成前检查
- [ ] 类名是否以 `Util` 结尾
- [ ] 是否添加了 JavaDoc 注释
- [ ] 是否进行了参数验证
- [ ] 是否避免了重复造轮子
- [ ] 是否避免了过度设计

### 生成中检查
- [ ] 是否按照规范定义方法
- [ ] 是否包含了必要的异常处理
- [ ] 是否遵循命名规范
- [ ] 是否避免了禁止的操作

### 生成后检查
- [ ] 是否通过编译检查
- [ ] 是否包含了所有必要的功能
- [ ] 是否符合命名规范
- [ ] 是否满足功能要求

## 相关规则
- 常量类: `04-conventions/constants.mdc`
